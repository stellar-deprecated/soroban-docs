---
sidebar_position: 1
title: Crowdfund Dapp Walkthrough
description: Step through the code behind the Crowdfund Dapp.
---

# Creating a Crowdfunding Dapp with Soroban

We'll be exploring an existing [End-to-End Example Soroban Dapp](https://github.com/stellar/soroban-example-dapp), using tools like Docker, Typescript, React, Rust, and Soroban. This project was created by the Soroban team and members of the community and is a fully-functioning crowdfunding dapp. Users can start fundraising campaigns, and others can donate directly on the website using Soroban Tokens.

1. [Introduction](#introduction)
2. [Prerequisites](#prerequisites)
3. [Understanding the Environment: Docker](#understanding-the-environment-docker)
4. [Our Crowdfunding Smart Contract](#our-crowdfunding-smart-contract)
5. [Understanding the Frontend: React](#understanding-the-frontend-react)
6. [Understanding Wallet Integration: Freighter](#understanding-wallet-integration-freighter)
7. [Understanding Dapp Initialization](#understanding-dapp-initialization-docker-scripts)
8. [Running the Example Dapp](#running-the-example-dapp)

## Prerequisites

- `soroban-cli v0.8.0`: [Download Soroban](https://soroban.stellar.org/docs/getting-started/setup#install-the-soroban-cli)
- `docker` (both Standalone and Futurenet backends require it): [Download Docker](https://www.docker.com/products/docker-desktop)
- `Node` v17: [Download Node](https://nodejs.org/en/download/)
- `Freighter Wallet`: [Freighter Wallet](https://freighter.app/)

## Setup

To get started with this walkthrough, simply clone the repository and navigate to it:

```bash
git clone https://github.com/stellar/soroban-example-dapp.git
cd soroban-example-dapp
```

## Understanding the Environment: Docker

Welcome to the world of Docker, an essential tool for software development. Docker packages software into units known as containers, ensuring consistency, isolation, portability, and scalability.

Docker is particularly useful in dApp development. It helps manage microservices, maintain consistent environments throughout development stages, and simulate a decentralized network during testing.

Understanding Docker begins with understanding Docker images and containers. A Docker image, created from a Dockerfile, is a package that contains everything needed to run the software. A Docker container is a running instance of this image.

### Building and Running the Crowdfunding Docker Image

You can create a Docker image using the docker build command with a Dockerfile. Once the image is created, you can run a Docker container using the Docker run command.

In the context of our crowdfunding dapp, understanding how to build Docker images is crucial. The Docker images serve as the basis for our container, which provides the environment for our Dapp to run.

To build our Docker image, we use a command encapsulated in our `Makefile`:

```bash
make build-docker
```

This command simplifies the Docker build process and ensures it's consistently executed each time. When you run `make build-docker`, Docker executes the following instructions:

```bash
docker build . \
 --tag soroban-preview:9 \
 --force-rm \
 --rm
```

### Here's what each component does:

```bash
docker build .
```

Instructs Docker to build an image using the Dockerfile in the current directory (denoted by the .).

```bash
--tag soroban-preview:9
```

Gives a name and tag to our image, in this case, soroban-preview with the tag 9.

```bash
--force-rm
```

Ensures Docker removes any intermediate containers after the build process completes. This keeps our environment clean.

```bash
--rm
```

Guarantees the removal of the intermediate container, even if the build fails. By using `make build-docker`, we're harnessing the power of Docker to create a consistent, reliable environment for our dApp.

## Our Crowdfunding Smart Contract

Our smart contract, written in Rust and using the Soroban SDK, represents a simple crowdfunding campaign. Users can deposit tokens into the contract until a target amount is reached or a deadline expires. If the target is met, the recipient can withdraw the tokens. If the deadline passes without the target being met, donors can reclaim their tokens.

Here's a breakdown of the contract's key functions:

### Initialize Function

The `initialize` function sets up the crowdfunding campaign. It takes in the following parameters:

- `recipient`: The address that will receive the funds if the campaign is successful.
- `deadline`: The timestamp at which the campaign ends.
- `target_amount`: The amount of tokens the campaign aims to raise.
- `token`: The token contract ID.

This function can only be called once, as checked by the assert statement at the start of the function.

```rust
pub fn initialize(
        e: Env,
        recipient: Address,
        deadline: u64,
        target_amount: i128,
        token: Address,
    ) {
        assert!(!e.storage().has(&DataKey::Recipient), "already initialized");

        e.storage().set(&DataKey::Recipient, &recipient);
        e.storage().set(&DataKey::RecipientClaimed, &false);
        e.storage()
            .set(&DataKey::Started, &get_ledger_timestamp(&e));
        e.storage().set(&DataKey::Deadline, &deadline);
        e.storage().set(&DataKey::Target, &target_amount);
        e.storage().set(&DataKey::Token, &token);
    }
```

### State Function

The `state` function plays a crucial role as it keeps us updated about the current status of our crowdfunding campaign. This function uses an enumeration named `State`, which has three potential states:

- `Running`: Indicates that the campaign is still ongoing. This is the initial state as long as the present time hasn't exceeded the campaign deadline.
- `Success`: Represents a scenario where the campaign has successfully hit or surpassed its target amount. This state is determined if the balance of tokens meets or exceeds the target amount.
- `Expired`: The campaign has surpassed its deadline without attaining the target amount. This state is declared if the current time has passed the deadline and the token balance hasn't met the target.

Here's what the enumeration and the `state` function look like:

```rust
pub enum State {
    Running = 0,
    Success = 1,
    Expired = 2,
}
```

The function `get_state` identifies the current state of the campaign, relying on the existing time, the campaign's deadline, and the balance of tokens in relation to the target amount:

```rust
fn get_state(e: &Env) -> State {
    let deadline = get_deadline(e);
    let token_id = get_token(e);
    let current_timestamp = get_ledger_timestamp(e);

    if current_timestamp < deadline {
        return State::Running;
    };
    if get_recipient_claimed(e) || target_reached(e, &token_id) {
        return State::Success;
    };
    State::Expired
}
```

### Deposit Function

The `deposit` function allows a user to contribute tokens to the campaign. It verifies that the campaign is still running and that the user is not the recipient. The function then updates the user's deposited amount and transfers the tokens from the user to the contract.

```rust
pub fn deposit(e: Env, user: Address, amount: i128) {
    user.require_auth();
    assert!(amount > 0, "amount must be positive");
    assert!(get_state(&e) == State::Running, "sale is not running");
    let token_id = get_token(&e);
    let current_target_met = target_reached(&e, &token_id);

    let recipient = get_recipient(&e);
    assert!(user != recipient, "recipient may not deposit");

    let balance = get_user_deposited(&e, &user);
    set_user_deposited(&e, &user, &(balance + amount));

    let client = token::Client::new(&e, &token_id);
    client.transfer(&user, &e.current_contract_address(), &amount);

    let contract_balance = get_balance(&e, &token_id);

    // emit events
    events::pledged_amount_changed(&e, contract_balance);
    if !current_target_met && target_reached(&e, &token_id) {
        // only emit the target reached event once on the pledge that triggers target to be met
        events::target_reached(&e, contract_balance, get_target_amount(&e));
    }
}
```

### Withdraw Function

The `withdraw` function allows users to withdraw their tokens. Depending on the campaign's state, different users are allowed to withdraw:

- If the campaign is `Running`, no one can withdraw tokens.
- If the campaign is `Success`, only the recipient can withdraw tokens.
- If the campaign is `Expired`, donors can withdraw their tokens, but the recipient cannot.

```rust
pub fn withdraw(e: Env, to: Address) {
    let state = get_state(&e);
    let recipient = get_recipient(&e);

    match state {
        State::Running => {
            panic!("sale is still running")
        }
        State::Success => {
            assert!(
                to == recipient,
                "sale was successful, only the recipient may withdraw"
            );
            assert!(
                !get_recipient_claimed(&e),
                "sale was successful, recipient has withdrawn funds already"
            );

            let token = get_token(&e);
            transfer(&e, &recipient, &get_balance(&e, &token));
            set_recipient_claimed(&e);
        }
        State::Expired => {
            assert!(
                to != recipient,
                "sale expired, the recipient may not withdraw"
            );

            // Withdraw full amount
            let balance = get_user_deposited(&e, &to);
            set_user_deposited(&e, &to, &0);
            transfer(&e, &to, &balance);

            // emit events
            let token_id = get_token(&e);
            let contract_balance = get_balance(&e, &token_id);
            events::pledged_amount_changed(&e, contract_balance);
        }
    };
}
```

### Testing the Crowdfunding Contract

This section serves as a description of the [unit tests](https://github.com/stellar/soroban-example-dapp/blob/main/contracts/crowdfund/src/test.rs) for the crowdfunding contract's functionality. The tests examine various states and events that could occur within a crowdfunding scenario, including situations of success, expiry, and ongoing campaigns.

We can test our crowdfunding contract using the Cargo test command. This command runs all the tests in our project. To do this, we must navigate to the `soroban-example-dapp/contracts/crowdfund/src` directory.

```bash
cd contracts/crowdfund/src
```

and run the following command:

```bash
cargo test
```

This command runs all the tests in our project. The output should look like this:

```bash
running 9 tests
test test::test_expired ... ok
test test::sale_still_running - should panic ... ok
test test::test_success ... ok
test test::sale_not_running - should panic ... ok
test test::sale_expired_recipient_not_allowed - should panic ... ok
test test::sale_successful_only_recipient - should panic ... ok
test test::sale_successful_non_recipient_still_denied_after_withdrawal - should panic ... ok
test test::test_events ... ok
test test::sale_successful_recipient_withdraws_only_once - should panic ... ok

test result: ok. 9 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.20s
```

Let's take a brief look at our test file:

`impl Setup`: This struct contains the setup for our tests. The function `new` within the `Setup` struct creates a new crowdfunding environment, preparing it for further tests. This is where all essential components for the crowdfunding scenario, such as the crowdfunding and token contracts, users, and relevant actions, are initialized. It's crucial for setting up the preconditions needed for each unit test scenario.

```rust
/// Sets up a crowdfund with -
/// 1. Deadline 10 seconds from now.
/// 2. Target amount of 15.
/// 3. One deposit of 10 from user1.
///
impl Setup<'_> {
    fn new() -> Self {
        let e: Env = soroban_sdk::Env::default();
        let recipient = Address::random(&e);
        let user1 = Address::random(&e);
        let user2 = Address::random(&e);

        // the deadline is 10 seconds from now
        let deadline = e.ledger().timestamp() + 10;
        let target_amount: i128 = 15;

        // Create the token contract
        let token_admin = Address::random(&e);
        let contract_token = e.register_stellar_asset_contract(token_admin);
        let token = Token::new(&e, &contract_token);

        // Create the crowdfunding contract
        let (crowdfund_id, crowdfund) =
            create_crowdfund_contract(&e, &recipient, deadline, &target_amount, &contract_token);

        // Mint some tokens to work with
        token.mock_all_auths().mint(&user1, &10);
        token.mock_all_auths().mint(&user2, &8);

        crowdfund.client().mock_all_auths().deposit(&user1, &10);

        Self {
            env: e,
            recipient,
            user1,
            user2,
            token,
            crowdfund,
            crowdfund_id,
        }
    }
}
```

`test_expired`: This test examines the behavior when the crowdfunding campaign expires without reaching its target amount. In this case, the user1 is expected to withdraw his deposited amount.

```rust
#[test]
fn test_expired() {
    let setup = Setup::new();
    advance_ledger(&setup.env, 11);

    setup
        .crowdfund
        .client()
        .mock_all_auths()
        .withdraw(&setup.user1);

    assert_eq!(setup.token.balance(&setup.user1), 10);
    assert_eq!(setup.token.balance(&setup.crowdfund_id), 0);
}
```

`sale_still_running`: This test ensures that the recipient can't withdraw the funds while the crowdfunding campaign is still running.

```rust
#[test]
#[should_panic(expected = "sale is still running")]
fn sale_still_running() {
    let setup = Setup::new();
    setup
        .crowdfund
        .client()
        .mock_all_auths()
        .withdraw(&setup.recipient);
}
```

`test_success`: This test checks the behavior when the crowdfunding campaign successfully reaches its target amount. It ensures that the funds can be withdrawn by the recipient after the deadline.

```rust
#[test]
fn test_success() {
    let setup = Setup::new();
    setup
        .crowdfund
        .client()
        .mock_all_auths()
        .deposit(&setup.user2, &5);

    assert_eq!(setup.token.mock_all_auths().balance(&setup.user1), 0);
    assert_eq!(setup.token.mock_all_auths().balance(&setup.user2), 3);
    assert_eq!(
        setup.token.mock_all_auths().balance(&setup.crowdfund_id),
        15
    );

    advance_ledger(&setup.env, 10);
    setup
        .crowdfund
        .client()
        .mock_all_auths()
        .withdraw(&setup.recipient);

    assert_eq!(setup.token.mock_all_auths().balance(&setup.user1), 0);
    assert_eq!(setup.token.mock_all_auths().balance(&setup.user2), 3);
    assert_eq!(setup.token.mock_all_auths().balance(&setup.crowdfund_id), 0);
    assert_eq!(setup.token.mock_all_auths().balance(&setup.recipient), 15);
}
```

`sale_not_running`: This test checks the behavior when a deposit attempt is made after the crowdfunding campaign has expired.

```rust
#[test]
#[should_panic(expected = "sale is not running")]
fn sale_not_running() {
    let setup = Setup::new();
    advance_ledger(&setup.env, 10);

    setup.crowdfund.client().deposit(&setup.user1, &1);
}
```

`sale_expired_recipient_not_allowed`: This test ensures that the recipient can't withdraw the funds if the crowdfunding campaign has expired without reaching the target amount.

```rust
#[test]
#[should_panic(expected = "sale expired, the recipient may not withdraw")]
fn sale_expired_recipient_not_allowed() {
    let setup = Setup::new();
    advance_ledger(&setup.env, 10);

    setup.crowdfund.client().withdraw(&setup.recipient);
}
```

`sale_successful_only_recipient`: This test verifies that only the recipient can withdraw the funds once the campaign is successful and no other users can do so.

```rust
#[test]
#[should_panic(expected = "sale was successful, only the recipient may withdraw")]
fn sale_successful_only_recipient() {
    let setup = Setup::new();
    setup.crowdfund.client().deposit(&setup.user2, &5);
    advance_ledger(&setup.env, 10);

    setup.crowdfund.client().withdraw(&setup.user1);
}
```

`sale_successful_non_recipient_still_denied_after_withdrawal`: This test ensures that users who aren't the recipient can't withdraw funds after the recipient has already done so.

```rust
#[test]
#[should_panic(expected = "sale was successful, only the recipient may withdraw")]
fn sale_successful_non_recipient_still_denied_after_withdrawal() {
    let setup = Setup::new();
    setup
        .crowdfund
        .client()
        .mock_all_auths()
        .deposit(&setup.user2, &5);
    advance_ledger(&setup.env, 10);

    setup
        .crowdfund
        .client()
        .mock_all_auths()
        .withdraw(&setup.recipient);
    setup
        .crowdfund
        .client()
        .mock_all_auths()
        .withdraw(&setup.user1);
}
```

`test_events`: This test ensures that the events are emitted correctly. It checks that the `pledged_amount_changed` event is emitted when a user makes a deposit and that the `target_reached` event is emitted when the target amount is reached.

```rust
#[test]
fn test_events() {
    let setup = Setup::new();
    setup
        .crowdfund
        .client()
        .mock_all_auths()
        .deposit(&setup.user2, &5);
    setup
        .crowdfund
        .client()
        .mock_all_auths()
        .deposit(&setup.user2, &3);

    let mut crowd_fund_events: Vec<(Address, soroban_sdk::Vec<RawVal>, RawVal)> = vec![&setup.env];

    // there are SAC events emitted also, filter those away, not asserting that aspect
    setup
        .env
        .events()
        .all()
        .iter()
        .map(core::result::Result::unwrap)
        .filter(|event| event.0 == setup.crowdfund_id)
        .for_each(|event| crowd_fund_events.push_back(event));

    assert_eq!(
        crowd_fund_events,
        vec![
            &setup.env,
            (
                setup.crowdfund_id.clone(),
                (Symbol::new(&setup.env, "pledged_amount_changed"),).into_val(&setup.env),
                10_i128.into_val(&setup.env)
            ),
            (
                setup.crowdfund_id.clone(),
                (Symbol::new(&setup.env, "pledged_amount_changed"),).into_val(&setup.env),
                15_i128.into_val(&setup.env)
            ),
            (
                // validate that this event only emitted once, ensuing deposits over the
                // target before expiration, don't trigger this one again
                setup.crowdfund_id.clone(),
                (Symbol::new(&setup.env, "target_reached"),).into_val(&setup.env),
                (15_i128, 15_i128).into_val(&setup.env)
            ),
            (
                setup.crowdfund_id.clone(),
                (Symbol::new(&setup.env, "pledged_amount_changed"),).into_val(&setup.env),
                18_i128.into_val(&setup.env)
            ),
        ]
    );
}
```

`sale_successful_recipient_withdraws_only_once`: This test ensures that the recipient can only withdraw the funds once, even if the campaign is successful.

```rust
#[test]
#[should_panic(expected = "sale was successful, recipient has withdrawn funds already")]
fn sale_successful_recipient_withdraws_only_once() {
    let setup = Setup::new();
    setup.crowdfund.client().deposit(&setup.user2, &5);
    advance_ledger(&setup.env, 10);

    setup
        .crowdfund
        .client()
        .mock_all_auths()
        .withdraw(&setup.recipient);
    setup
        .crowdfund
        .client()
        .mock_all_auths()
        .withdraw(&setup.recipient);
}
```

## Understanding the Frontend: React

This section elaborates on how our frontend can interact with our crowdfund contract, access chain data, and connect to our Freighter wallet. We will accomplish this by utilizing libraries provided by [`@soroban-react`](https://soroban-react.gitbook.io/index/), a simple, powerful framework for building modern Soroban Dapps using React created by a member of the Soroban community.

Below is a list of the libraries used throughout the frontend code and their respective imports:

```jsx
import { SorobanReactProvider } from "@soroban-react/core";
import { futurenet, sandbox, standalone } from "@soroban-react/chains";
import { freighter } from "@soroban-react/freighter";
import { ChainMetadata, Connector } from "@soroban-react/types";
import type {
  WalletChain,
  ChainMetadata,
  ChainName,
} from "@soroban-react/types";
import { useSorobanReact } from "@soroban-react/core";
```

### Understanding the Interaction

The interaction between our frontend and smart contracts is facilitated by an RPC endpoint. This endpoint might reside on your local machine if you're operating a local network for development, or it could be hosted on a remote server if you're interfacing with the main or test networks.

The frontend application communicates with this RPC endpoint, initiating requests that can pull data from the network, interacting with smart contracts, or executing transactions. In the context of our crowdfunding dapp, these transactions can vary from invoking functions within the existing crowdfunding smart contract such as minting tokens, contributing to a campaign, or withdrawing funds. Additionally, the frontend is used to connect to the user's [Freighter wallet](https://www.freighter.app), which is used to securely sign and submit transactions.

### Understanding the Frontend Code

The frontend code for our crowdfunding dapp is located in the `soroban-example-dapp/pages` and `soroban-example-dapp/components` directories. The frontend is built using React, a popular JavaScript library for building user interfaces. React is a component-based library, meaning that it allows developers to build encapsulated components that manage their own state. These components can then be composed to create complex user interfaces.

### Index

Let's take a look at the [`soroban-example-dapp/pages/index.tsx`](https://github.com/stellar/soroban-example-dapp/blob/main/pages/index.tsx) file:

```tsx
import React from "react";
import type { NextPage } from "next";
import Head from "next/head";
import styles from "../styles/Home.module.css";
import { Campaign, Pledge } from "../components/organisms";
import { WalletData } from "../components/molecules";

const Home: NextPage = () => {
  return (
    <>
      <Head>
        <title>
          Crowdfund Template - An example of how to run a crowdfund campaign on
          Soroban.
        </title>
        <meta
          name="description"
          content="An example of loading information from a soroban smart contract"
        />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <header className={styles.header}>
        <h3>Starfund</h3>
        <WalletData />
      </header>
      <main className={styles.main}>
        <div className={styles.content}>
          <Campaign />
          <Pledge />
        </div>
      </main>
    </>
  );
};

export default Home;
```

The `Home` component is the main component of our application. It's composed of two subcomponents, `Campaign` and `Pledge`, which are located in the `soroban-example-dapp/components/organisms` directory. The `WalletData` component, located in the `soroban-example-dapp/components/molecules` directory, is used to display the user's wallet address and balance.

These are the main components that make up our crowdfunding dapp that we'll be exploring in the next sections.

### Campaign Component

The [`Campaign`](https://github.com/stellar/soroban-example-dapp/blob/main/components/organisms/campaign/index.tsx) component is responsible for displaying the crowdfunding campaign information. It's composed of the `AuthorInfo` component, which displays the author's name, the date and time the campaign was created, and the author's avatar. The `Campaign` component also displays the campaign's title, description, and image.

`components/organisms/campaign/index.tsx `

```tsx
import React from "react";
import styles from "./style.module.css";
import Image from "next/image";
import picture from "../../../assets/example.png";
import { AuthorInfo } from "../../atoms";
import avatar from "../../../assets/avatar.png";

export function Campaign() {
  return (
    <div className={styles.content}>
      <h6>Starfund #821</h6>
      <h1>Planetary open-source photography</h1>
      <AuthorInfo author="Sam Stroop" dateTime="21 hours ago" image={avatar} />
      <Image src={picture} width={642} height={294} alt="project image" />
      <p>
        Hello! My name is Sam and Iâ€™m working with a team of three other
        passionate individuals to take photos of the planets in our solar system
        and make them open-source to the world! We are fascinated by the stars
        and the system and we think images of these entities should be shared
        with everyone.
      </p>
      <p>
        Our hope is that by making these open-source, people will be able to use
        them for personal, educational, and even commercial purposes. We are
        raising funds to help cover the cost of equipment and time spent on this
        project. Any amount helps and we are grateful for your support!
      </p>
    </div>
  );
}
```

### Pledge Component

The `Pledge` component is where users interact with the crowdfunding application, pledging tokens to the campaign of their choice. It serves as a data entry point, data fetcher, and presenter.

It uses contract RPC calls to pull important info from the token and crowdfunding contracts. It's interested in things like token balance, decimals, name, and symbol, along with the crowdfunding contract's deadline and target amount.

Let's breakdown the `Pledge` component into its constituent parts:

#### Progress Bar

Data is presented in two ways. First, a progress bar displays the current contribution status relative to the target goal.

`components/atoms/progress-bar/index.tsx`

```tsx
export interface ProgressBarProps {
  value: number;
}

export function ProgressBar({ value }: ProgressBarProps) {
  return (
    <div className={styles.progressBarBackground}>
      <div className={styles.progressBar} style={{ width: value + "%" }} />
    </div>
  );
}
```

Next, it shows a countdown timer, letting users know exactly how much time remains to contribute.

#### Countdown Timer

`components/organisms/pledge/index.tsx`

```tsx
<h6>Time remaining</h6>
<span className={styles.values}>
{Utils.getRemainingTime(deadlineDate)}
</span>
```

`components/shared/utils/index.tsx`

```tsx
const getRemainingTime = (date?: Date): string => {
  if (!date) {
    return "Undefined";
  }
  const diff = moment(date).diff(Date.now());

  if (isExpired(date)) {
    return "Expired";
  }

  return (
    humanizeDuration(diff, {
      round: true,
      conjunction: " and ",
      largest: 1,
    }) + " left"
  );
};
```

#### Wallet Connector

For users who haven't connected their wallet yet, the application provides a conveniently placed button to do so.

```tsx
import React from "react";
import { useSorobanReact } from "@soroban-react/core";
import styles from "./style.module.css";
export interface ConnectButtonProps {
  label: string;
  isHigher?: boolean;
}

export function ConnectButton({ label, isHigher }: ConnectButtonProps) {
  const { connect } = useSorobanReact();
  const openConnectModal = async () => {
    await connect();
  };

  return (
    <button
      className={styles.button}
      style={{ height: isHigher ? 50 : 38 }}
      onClick={openConnectModal}
    >
      {" "}
      {label}{" "}
    </button>
  );
}
```

This `ConnectButton` component uses the `useSorobanReact` hook from the Soroban SDK to call the `connect` function.

`ConnectButtonProps` passes in a `label` prop, which is the text that will be displayed on the button, and an optional `isHigher` prop that modifies the button's height.

When the `ConnectButton` is clicked, the `openConnectModal` function is invoked. This function asynchronously calls the `connect` method provided by `useSorobanReact`, initiating the wallet connection process.

### Hooks and Methods

The `Pledge` component uses various hooks and methods to interact with Soroban smart contracts, extract data, update UI states, and handle events.

Let's take a look at `components/organisms/pledge/index.tsx`

#### Loading Contract Values

```tsx
const useLoadToken = (): any => {
  return {
    balance: useContractValue({
      contractId: Constants.TokenId,
      method: 'balance',
      params: [SorobanClient.Address.contract(Buffer.from(Constants.CrowdfundId, 'hex')).toScVal()],
      sorobanContext
    }),
...
let token = useLoadToken()
  };
}
```

The `useLoadToken` hook is used to fetch token properties such as balance, decimals, name, and symbol. These properties are fetched using the `useContractValue` hook, which makes calls to the contract.

#### Converting Contract Values to JS Types

```tsx
const tokenDecimals =
token.decimals.result && (token.decimals.result?.u32() ?? 7);
...
const targetAmount = convert.scvalToBigNumber(targetAmountXdr.result);
```

The contract values (ScVals) are converted to standard JavaScript types for use within the React component. This conversion is performed by helper functions such as `convert.scvalToBigNumber`.

#### Updating UI with useEffect Hook

React's `useEffect` hook is an integral part of this component. It's responsible for updating the UI based on changes to the contract values. Let's take a closer look:

```tsx
React.useEffect(() => {
  // hook is providing data, let it update the UI model,
  // events will update these later also
  const tokenBalance = convert.scvalToBigNumber(token.balance.result);
  const targetAmount = convert.scvalToBigNumber(targetAmountXdr.result);
  setTokenBalance(tokenBalance);
  setTargetReached(targetAmount.gt(0) && tokenBalance.gte(targetAmount));
}, [token.balance, targetAmountXdr]);
```

`useEffect` here accepts two arguments:

- A function that contains side effects. Here, it's updating our state variables: `tokenBalance` and `targetReached`.
- An array of dependencies. If any dependency changes, the function (first argument) re-executes.

The dependencies are `token.balance` and `targetAmountXdr`, implying the function re-runs if the token balance or target amount change.

Within the function, we convert `token.balance.result` and `targetAmountXdr`.result from `ScVal` format (Soroban's data type) to `BigNumber` using `convert.scvalToBigNumber. BigNumber`.

After the conversion, we use `setTokenBalance` and `setTargetReached` to update our state variables. `setTargetReached` checks if the target amount is greater than zero and the token balance meets or exceeds this target.

The result? A UI that instantly reflects changes to the token balance or target amount.

#### Checking Loading State

```tsx
const isLoading = (): boolean | undefined => {
...
}
```

The `isLoading` function checks the loading status of various contract properties. If any of these properties are still being fetched, the function returns true.

#### Event Subscriptions

The component sets up two event subscriptions to handle real-time updates from the contract. These subscriptions are for the 'pledged_amount_changed' and 'target_reached' events.

The subscription is created using the `useRef` hook to create a mutable object that persists across re-renders without causing additional renders.

Each subscription is an object that specifies the contract ID, the events to listen for, a callback function that handles the event, and a unique ID.

The callback functions use the event data to update the component's state using the `setTokenBalance` and `setTargetReached` state setters.

In the case of the 'pledged_amount_changed' event, the balance from the event data is converted to a `BigNumber` and then set as the new token balance.

For the 'target_reached' event, the `setTargetReached` function is called with `true` to indicate that the crowdfunding target has been reached.

These subscriptions are set up in a `useEffect` hook that is run when the component mounts. The `sorobanEventsContext.subscribe` function is used to subscribe to the events, and it returns an ID for the subscription.

The `useEffect` hook also returns a cleanup function that is run when the component unmounts. This function calls `sorobanEventsContext.unsubscribe` with the subscription IDs to stop listening to the events.

```tsx
const crowdfundPledgedEventSubscription = useRef({
  contractId: Constants.CrowdfundId,
  topics: ["pledged_amount_changed"],
  cb: (event: SorobanClient.SorobanRpc.EventResponse): void => {
    let eventTokenBalance = xdr.ScVal.fromXDR(event.value.xdr, "base64");
    setTokenBalance(convert.scvalToBigNumber(eventTokenBalance));
  },
  id: Math.random(),
} as EventSubscription);

const crowdfundTargetReachedSubscription = useRef({
  contractId: Constants.CrowdfundId,
  topics: ["target_reached"],
  cb: (event: SorobanClient.SorobanRpc.EventResponse): void => {
    setTargetReached(true);
  },
  id: Math.random(),
} as EventSubscription);

React.useEffect(() => {
  const pledgedSubId = sorobanEventsContext.subscribe(
    crowdfundPledgedEventSubscription.current
  );
  const reachedSubId = sorobanEventsContext.subscribe(
    crowdfundTargetReachedSubscription.current
  );

  return () => {
    sorobanEventsContext.unsubscribe(pledgedSubId);
    sorobanEventsContext.unsubscribe(reachedSubId);
  };
}, [sorobanEventsContext]);
```

### Making Contributions

The `Pledge` component also allows users to make contributions to the crowdfunding campaign. It does this by using the `FormPledge` component, which is located in the `soroban-example-dapp/components/molecules` directory.

#### Form Pledge

The `FormPledge` component plays a crucial role in facilitating user interaction with the application. It allows users with connected wallets to make pledges, therefore contributing to a crowdfunding campaign. To carry out its functions, `FormPledge` relies on several key aspects.

First, there's `IFormPledgeProps`, an interface that specifies the types of data required to make a pledge:

`components/molecules/form-pledge/index.tsx`

```tsx
export interface IFormPledgeProps {
  account: string;
  tokenId: string;
  crowdfundId: string;
  decimals: number;
  networkPassphrase: string;
  symbol?: string;
}
```

This interface includes information about the user's account, the token being used for the pledge, the ID of the specific crowdfunding campaign, and the network passphrase.

In the `FormPledge` component, we then make use of the `useSorobanReact` hook:

```tsx
const FormPledge: FunctionComponent<IFormPledgeProps> = (props) => {
  const sorobanContext = useSorobanReact();
};
```

This hook enables `FormPledge` to access and interact with the functionalities provided by the Soroban SDK. The created `sorobanContext` sets up the necessary environment for transactions to take place.

Finally, `FormPledge` uses the `useSendTransaction` hook to dispatch the pledge transaction to the Soroban network:

```tsx
try {
      // Deposit the tokens
      let result = await sendTransaction(
        contractTransaction(
          props.networkPassphrase,
          source,
          props.crowdfundId,
          'deposit',
          new SorobanClient.Address(props.account).toScVal(),
          amountScVal
        ),
        {sorobanContext}
      )
}
```

This snippet constructs a 'deposit' transaction with all the necessary details, like the network passphrase, source account, crowdfunding campaign ID, the 'deposit' operation, the user's account, and the pledge amount. Once created, the transaction is sent to the network via the `sendTransaction` function. The previously established `sorobanContext` is passed in as an argument to ensure the transaction is dispatched in the right context. This context carries crucial settings and state information, like the wallet's autoconnect status, available chains and connectors, active chain and connector, and a user's account address, among others.

You can find more about the details of `sendTransaction` and `sorobanContext` in the `@soroban-react/core` node modules.

#### Previous Pledges

For users who have their wallets connected, the `Deposits` component offers a recap of their past contributions.

This part of the interface showcases the total amount of tokens pledged by the user. It offers a clear and concise representation, formatted nicely with the help of a utility function. This way, users can at a glance view their contributions towards the crowdfunding goal.

```tsx

<h6>PLEDGED</h6>
<div className={styles.pledgeAmount}>
  {Utils.formatAmount(tokenBalance, tokenDecimals)} {tokenSymbol}
</div>
```

In this snippet, `tokenBalance` refers to the total amount pledged, and `tokenSymbol` is the type of token used. The `Utils.formatAmount` function takes care of presenting these values in a user-friendly way.

Throughout all these operations, the `Pledge` component also manages loading states efficiently, ensuring a smooth and engaging user interface.

### Minting

Minting is the process of creating new tokens. Within our crowdfunding application, we've implemented a feature allowing users to mint new EXT tokens before they pledge them.

The `MintButton` function encapsulates this functionality. It takes in three properties: `account`, `decimals`, and `symbol`.

```tsx
function MintButton({
  account,
  decimals,
  symbol,
}: {
  account: string;
  decimals: number;
  symbol: string;
}) {
  const [isSubmitting, setSubmitting] = useState(false);
  const { activeChain, server } = useNetwork();
  const networkPassphrase = activeChain?.networkPassphrase ?? "";
  const { sendTransaction } = useSendTransaction();
  const amount = BigNumber(100);
}
```

In this setup, the component receives the `account`, `decimals`, and `symbol` as props and uses the `useState` hook to manage the `isSubmitting` state, which represents whether a transaction is in progress. It also uses the `useNetwork` and `useSendTransaction` hooks to get the active blockchain network details and the `sendTransaction` function, respectively.

Upon clicking the `MintButton`, a series of steps unfold to carry out the minting process.

```tsx
<Button
  title={`Mint ${amount.toString()} ${symbol}`}
  onClick={async () => {
    setSubmitting(true);
    if (!server) throw new Error("Not connected to server");
  }}
/>
```

It starts by setting the `isSubmitting` state to true and checks the existence of the `server` to ensure there's a connection. If the `server` doesn't exist, an error is thrown.

```tsx
let adminSource, walletSource;
try {
  adminSource = await server.getAccount(Constants.TokenAdmin);
  walletSource = await server.getAccount(account);
} catch (error) {
  alert("Your wallet or the token admin wallet might not be funded");
  setSubmitting(false);
  return;
}
```

Next, it fetches the token admin account details (represented as `adminSource`) and the wallet source account details. In case there's an error, perhaps due to an unfunded wallet, an alert is displayed and the submission state is reset.

#### Trustline

Following this, a trustline is established for the admin, allowing the user to receive the minted asset.

```tsx
try {
  console.log("Establishing the trustline...");
  const trustlineResult = await sendTransaction(
    new SorobanClient.TransactionBuilder(walletSource, {
      networkPassphrase,
      fee: "1000", // arbitrary
    })
      .setTimeout(60)
      .addOperation(
        SorobanClient.Operation.changeTrust({
          asset: new SorobanClient.Asset(symbol, Constants.TokenAdmin),
        })
      )
      .build(),
    {
      timeout: 60 * 1000, // should be enough time to approve the tx
      skipAddingFootprint: true, // classic = no footprint
      sorobanContext, // to prompt Freighter for signing
    }
  );
  console.debug(trustlineResult);
} catch (err) {
  console.log("Error while establishing the trustline: ", err);
  console.error(err);
}
```

Here's a detailed explanation of the steps:

- Initiating the Trustline Transaction: A new transaction is built using `new SorobanClient.TransactionBuilder(walletSource, {...})`. The builder takes the walletSource as the source account for the transaction and an object with networkPassphrase and fee as configuration parameters.

- Setting the Transaction Timeout: `.setTimeout(60)` configures the maximum time the transaction should wait for approval before it gets discarded.

- Adding the Trustline Operation: `.addOperation(...)` includes a `changeTrust` operation to the transaction. This operation allows the `walletSource` to trust the asset identified by `symbol` from `Constants.TokenAdmin`.

- Building the Transaction: `.build()` finalizes the transaction construction and returns a transaction object ready to be sent.

- Sending the Transaction: `sendTransaction(...)` sends the transaction to the blockchain. It takes the built transaction and an options object as arguments. The options object specifies the `timeout` for the operation, whether to `skipAddingFootprint`, and the `sorobanContext`.

- Logging the Transaction Result: After the transaction is sent, the result is stored in `trustlineResult` and logged to the console.

#### Minting Operation

After successfully setting up a trustline, the token minting operation begins. This procedure sends a transaction from the token admin account to the user's account, effectively creating new tokens.

Below is the main code snippet responsible for the minting operation:

```tsx
try {
  console.log("Minting the token...");
  const paymentResult = await sendTransaction(
    new SorobanClient.TransactionBuilder(adminSource, {
      networkPassphrase,
      fee: "1000",
    })
      .setTimeout(10)
      .addOperation(
        SorobanClient.Operation.payment({
          destination: walletSource.accountId(),
          asset: new SorobanClient.Asset(symbol, Constants.TokenAdmin),
          amount: amount.toString(),
        })
      )
      .build(),
    {
      timeout: 10 * 1000,
      skipAddingFootprint: true,
      secretKey: Constants.TokenAdminSecretKey,
      sorobanContext,
    }
  );
  console.debug(paymentResult);
  sorobanContext.connect();
} catch (err) {
  console.log("Error while minting the token: ", err);
  console.error(err);
}
```

Let's breakdown the steps involved:

- Initiating the Minting Transaction: A new transaction is initiated with `new SorobanClient.TransactionBuilder(adminSource, {...})`. In this case, adminSource (the account of the token admin) is used as the source account for the minting transaction.

- Setting the Transaction Timeout: The timeout for the minting transaction is set to 10 seconds using `.setTimeout(10)`.

- Adding the Minting Operation: `.addOperation(...)` is used to add a payment operation to the transaction. Despite the term 'payment', in this context, it's utilized to mint new tokens. The operation sends the specified amount of the `asset` (identified by `symbol` from `Constants.TokenAdmin`) to the `destination` account, which is `walletSource.accountId()`.

- Building the Transaction: `.build()` finalizes the transaction construction and returns a transaction object ready to be sent.

- Sending the Transaction: `sendTransaction(...)` sends the transaction to the blockchain. It takes the built transaction and an options object as arguments. The options object specifies the `timeout` for the operation, whether to `skipAddingFootprint`, the `secretKey` for the token admin, and the `sorobanContext`.

- Handling the Transaction Result: The `paymentResult` from the transaction is logged for debugging purposes, and the `sorobanContext` is reconnected to keep the user's session active. If there's an error during this operation, the error is logged to the console.

## Understanding Wallet Integration: Freighter

Freighter is a browser extension that allows users to securely store their Stellar accounts and sign transactions. It's a convenient way to manage your Stellar accounts and interact with the Stellar network.

In our application, the `WalletData` component, located in `components/molecules/wallet-data/index.tsx`, plays a key role in wallet integration. Let's break down the code and understand its functionality:

```tsx
import React from "react";
import { DropdownSvg } from "../../../assets/icons";
import { useAccount, useIsMounted, useNetwork } from "../../../wallet";
import { ConnectButton } from "../../atoms";
import styles from "./style.module.css";
import Image from "next/image";

export function WalletData() {
  const mounted = useIsMounted();
  const { data: account } = useAccount();
  const { activeChain: chain, chains } = useNetwork();
  const unsupportedChain = chain?.unsupported;

  return (
    <>
      {mounted && account ? (
        <div className={styles.displayData}>
          {chain && (chains.length > 1 || unsupportedChain) && (
            <div className={styles.card}>
              {chain.iconUrl && (
                <Image
                  alt={chain.name ?? "Chain icon"}
                  style={{
                    background: chain.iconBackground,
                  }}
                  height="24"
                  src={chain.iconUrl}
                  width="24"
                />
              )}
              {chain.name ?? chain.id}
            </div>
          )}
          <div className={styles.card}>{account.displayName}</div>
        </div>
      ) : (
        <ConnectButton label="Connect Wallet" />
      )}
    </>
  );
}
```

Here's a breakdown of the code:

- The `mounted` variable is obtained using the `useIsMounted` hook, indicating whether the component is currently mounted or not.

- The `useAccount` hook is used to fetch the user's account data, and the `data` property is destructured from the result.

- The `useNetwork` hook is employed to access information about the active blockchain network and available chains. The activeChain and chains properties are destructured from the result.

- The `unsupportedChain` variable checks if the active chain is unsupported.

- Conditional rendering is used to display different content based on the component's mount status and the availability of account data.

- If the component is mounted and the account data is available, the user's wallet data is displayed. This includes the chain icon (if available), obtained from chain.iconUrl, and the chain name or ID. The account's display name is also shown.

- If there are multiple chains available or the active chain is unsupported, a chain card with the chain icon and name (or ID) is displayed.

- If the component is not mounted or the account data is not available, a `ConnectButton` component is rendered, allowing the user to connect their wallet.

## Understanding Dapp Initialization: Docker Scripts

The Dapp initialization process involves using Docker scripts to set up the necessary environment for running the application. Let's explore the provided scripts:

#### quickstart.sh

```bash
#!/bin/bash

set -e

case "$1" in
standalone)
    echo "Using standalone network"
    ARGS="--standalone"
    ;;
futurenet)
    echo "Using Futurenet network"
    ARGS="--futurenet"
    ;;
*)
    echo "Usage: $0 standalone|futurenet"
    exit 1
    ;;
esac

# this is set to the quickstart `soroban-dev` image annointed as the release
# for a given Soroban Release, it is captured on Soroban Releases - https://soroban.stellar.org/docs/reference/releases
QUICKSTART_SOROBAN_DOCKER_SHA=stellar/quickstart:soroban-dev@sha256:57e8ab498bfa14c65595fbb01cb94b1cdee9637ef2e6634e59d54f6958c05bdb

shift

# Run the soroban-preview container
# Remember to do:
# make build-docker

echo "Creating docker soroban network"
(docker network inspect soroban-network -f '{{.Id}}' 2>/dev/null) \
  || docker network create soroban-network

echo "Searching for a previous soroban-preview docker container"
containerID=$(docker ps --filter="name=soroban-preview" --all --quiet)
if [[ ${containerID} ]]; then
    echo "Start removing soroban-preview container."
    docker rm --force soroban-preview
    echo "Finished removing soroban-preview container."
else
    echo "No previous soroban-preview container was found"
fi

currentDir=$(pwd)
docker run -dti \
  --volume ${currentDir}:/workspace \
  --name soroban-preview \
  -p 8001:8000 \
  --ipc=host \
  --network soroban-network \
  soroban-preview:9

# Run the stellar quickstart image

docker run --rm -ti \
  --name stellar \
  --network soroban-network \
  -p 8000:8000 \
  "$QUICKSTART_SOROBAN_DOCKER_SHA" \
  $ARGS \
  --enable-soroban-rpc \
  "$@" # Pass through args from the CLI
```

The `quickstart.sh` script sets up the Docker environment for running the Dapp. It allows you to choose between a standalone network or the Futurenet network. The script performs the following steps:

- Determines the network based on the provided argument (`standalone` or `futurenet`).
- Creates the Docker network named `soroban-network` if it doesn't exist.
- Removes any existing `soroban-preview` Docker container.
- Runs the `soroban-preview` container, which provides the Soroban Preview environment for development.
- Runs the `stellar/quickstart` Docker image, which sets up the Stellar network using the chosen network type and enables Soroban RPC.

#### initialize.sh

```bash
#!/bin/bash

set -e

NETWORK="$1"

# If soroban-cli is called inside the soroban-preview docker containter,
# it can call the stellar standalone container just using its name "stellar"
if [[ "$IS_USING_DOCKER" == "true" ]]; then
  SOROBAN_RPC_HOST="http://stellar:8000"
else
  SOROBAN_RPC_HOST="http://localhost:8000"
fi

SOROBAN_RPC_URL="https://rpc-futurenet.stellar.org"

case "$1" in
standalone)
  echo "Using standalone network"
  SOROBAN_NETWORK_PASSPHRASE="Standalone Network ; February 2017"
  FRIENDBOT_URL="$SOROBAN_RPC_HOST/friendbot"
  ;;
futurenet)
  echo "Using Futurenet network"
  SOROBAN_NETWORK_PASSPHRASE="Test SDF Future Network ; October 2022"
  FRIENDBOT_URL="https://friendbot-futurenet.stellar.org/"
  ;;
*)
  echo "Usage: $0 standalone|futurenet"
  exit 1
  ;;
esac


echo Add the $NETWORK network to cli client
soroban config network add \
  --rpc-url "$SOROBAN_RPC_URL" \
  --network-passphrase "$SOROBAN_NETWORK_PASSPHRASE" "$NETWORK"

if !(soroban config identity ls | grep token-admin 2>&1 >/dev/null); then
  echo Create the token-admin identity
  soroban config identity generate token-admin
fi
TOKEN_ADMIN_SECRET="$(soroban config identity show token-admin)"
TOKEN_ADMIN_ADDRESS="$(soroban config identity address token-admin)"

# TODO: Remove this once we can use `soroban config identity` from webpack.
mkdir -p .soroban-example-dapp
echo "$TOKEN_ADMIN_SECRET" > .soroban-example-dapp/token_admin_secret
echo "$TOKEN_ADMIN_ADDRESS" > .soroban-example-dapp/token_admin_address

# This will fail if the account already exists, but it'll still be fine.
echo Fund token-admin account from friendbot
curl --silent -X POST "$FRIENDBOT_URL?addr=$TOKEN_ADMIN_ADDRESS" >/dev/null

ARGS="--network $NETWORK --source token-admin"

echo Wrap the Stellar asset
TOKEN_ID=$(soroban lab token wrap $ARGS --asset "EXT:$TOKEN_ADMIN_ADDRESS")
echo "Token wrapped succesfully with TOKEN_ID: $TOKEN_ID"

# TODO - remove this workaround when
# https://github.com/stellar/soroban-tools/issues/661 is resolved.
TOKEN_ADDRESS="$(node ./address_workaround.js $TOKEN_ID)"
echo "Token Address converted to StrKey contract address format:" $TOKEN_ADDRESS

echo -n "$TOKEN_ID" > .soroban-example-dapp/token_id

echo Build the crowdfund contract
make build

echo Deploy the crowdfund contract
CROWDFUND_ID="$(
  soroban contract deploy $ARGS \
    --wasm target/wasm32-unknown-unknown/release/soroban_crowdfund_contract.wasm
)"
echo "Contract deployed succesfully with ID: $CROWDFUND_ID"
echo "$CROWDFUND_ID" > .soroban-example-dapp/crowdfund_id

echo "Initialize the crowdfund contract"
deadline="$(($(date +"%s") + 86400))"
soroban contract invoke \
  $ARGS \
  --id "$CROWDFUND_ID" \
  -- \
  initialize \
  --recipient "$TOKEN_ADMIN_ADDRESS" \
  --deadline "$deadline" \
  --target_amount "1000000000" \
  --token "$TOKEN_ADDRESS"

echo "Done"
```

The `initialize.sh` script is responsible for initializing the Dapp's contracts and configurations. It performs the following tasks:

- Sets the network based on the provided argument (standalone or Futurenet).
- Determines the Soroban RPC host URL based on whether the script is running inside the soroban-preview Docker container or locally.
- Sets the Soroban RPC URL using the determined host URL.
- Sets the Soroban network passphrase and the Friendbot URL based on the chosen network.
- Adds the specified network configuration using Soroban config network add.
- Generates the token-admin identity using Soroban config identity generate.
- Retrieves the TOKEN_ADMIN_SECRET and TOKEN_ADMIN_ADDRESS values from the generated identity.
- Stores the TOKEN_ADMIN_SECRET and TOKEN_ADMIN_ADDRESS in the .soroban directory. Funds the token-admin account using the Friendbot service.
- Wraps the Stellar asset using soroban lab token wrap and stores the TOKEN_ID.
- Builds the crowdfund contract using make build. Deploys the crowdfund contract using Soroban contract deploy and stores the CROWDFUND_ID.
- Initializes the crowdfund contract by invoking the initialize function with the required parameters.
- Prints "Done" to indicate the completion of the initialization process.

## Running the Example Dapp

Now that we've explored the code for our crowdfunding dapp, let's take on the [Crowdfund Dapp Challenge!](../challenge-0-crowdfund)
