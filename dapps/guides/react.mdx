---
sidebar_position: 1
title: React
description: Learn about the frontend for the example Crowdfund Dapp.
---

## Example Frontend Overview

This section elaborates on how the frontends from our example dapps can interact with the example contracts and access chain data, and connect to a freighter. This will be accomplished by utilizing libraries provided by [`@soroban-react`](https://soroban-react.gitbook.io/index/), a simple, powerful framework for building modern Soroban Dapps using React created by a member of the Soroban community.

Below is a list of the libraries used throughout the frontend code and their respective imports:

```jsx
import { SorobanReactProvider } from "@soroban-react/core";
import { futurenet, sandbox, standalone } from "@soroban-react/chains";
import { freighter } from "@soroban-react/freighter";
import { ChainMetadata, Connector } from "@soroban-react/types";
import type {
  WalletChain,
  ChainMetadata,
  ChainName,
} from "@soroban-react/types";
import { useSorobanReact } from "@soroban-react/core";
```

These imports include `SorobanReactProvider` from `@soroban-react/core`, which is a context provider used to pass the SorobanReact instance to other components. We also import several types such as `WalletChain`, `ChainMetadata`, and `ChainName`, which help to maintain type safety within our application.

## React Components and Prop Passing

React thrives on its component-based architecture. Components are reusable pieces of code that return a React element to be rendered on the page. A typical React application consists of multiple components working harmoniously to create a dynamic user interface.

Let's look at a component from the the example Crowdfund Dapp, the `MintButton` component:

```tsx
function MintButton({
  account,
  decimals,
  symbol,
}: {
  account: string;
  decimals: number;
  symbol: string;
}) {
  const [isSubmitting, setSubmitting] = useState(false);
  const { activeChain, server } = useNetwork();
  const networkPassphrase = activeChain?.networkPassphrase ?? "";
  const { sendTransaction } = useSendTransaction();
  const amount = BigNumber(100);
}
```

This functional component takes three properties as arguments: `account`, `decimals`, and `symbol`. It demonstrates the concept of prop passing, a way to pass data from parent to child components in React. It also uses React's `useState` hook for local state management, a method to preserve values between function calls.

## State Management and Hooks

State management is another core concept of React, allowing components to create and manage their own data. The `useState` hook is a feature introduced in React 16.8 that allows functional components to have their own state.

In the `MintButton` component, the `useState` hook is used to manage the `isSubmitting` state:

```tsx
const [isSubmitting, setSubmitting] = useState(false);
```

The `useState` hook returns a pair of values: the current state and a function that updates it. In this case, the `isSubmitting` state is initialized to `false` and the `setSubmitting` function is used to update it. React also allows for the creation of custom hooks, like `useNetwork` and `useSendTransaction`, for encapsulating and reusing stateful logic across multiple components.

## Custom Hooks

React hooks are functions that let you “hook into” React state and lifecycle features from functional components. Custom hooks allow you to encapsulate complex logic and make it reusable across components. Let's take a look at `useNetwork` and `useSendTransaction`, two custom hooks used in the example Crowdfund Dapp.

The `useNetwork` hook is utilized to interact with the blockchain network, and the `useSendTransaction` hook is used to dispatch transactions. These hooks abstract away complex logic, making it easier to read and understand the main component code.

Here's how we use these hooks in the `MintButton` component:

```tsx
function MintButton({
  account,
  decimals,
  symbol,
}: {
  account: string;
  decimals: number;
  symbol: string;
}) {
  const [isSubmitting, setSubmitting] = useState(false);
  const { activeChain, server } = useNetwork();
  const networkPassphrase = activeChain?.networkPassphrase ?? "";
  const { sendTransaction } = useSendTransaction();
  const amount = BigNumber(100);
}
```

`useNetwork` provides the active chain and the server, and `useSendTransaction` gives us the `sendTransaction` method, which we'll later use to mint tokens. This way, we can keep the component focused on rendering and event handling logic, making it easier to test and maintain.

## Asynchronous Processing and Robust Error Handling
When dealing with operations that might take an unpredictable amount of time, like network requests or, in our case, minting tokens on the blockchain, React's support for asynchronous operations is crucial. This allows the execution of the rest of the code without being blocked by these operations.

Let's dive into the code snippet that handles the asynchronous minting process:

```tsx
try {
  console.log("Minting the token...");
  const paymentResult = await sendTransaction(
    new SorobanClient.TransactionBuilder(adminSource, {
      networkPassphrase,
      fee: "1000",
    })
      .setTimeout(10)
      .addOperation(
        SorobanClient.Operation.payment({
          destination: walletSource.accountId(),
          asset: new SorobanClient.Asset(symbol, Constants.TokenAdmin),
          amount: amount.toString(),
        })
      )
      .build(),
    {
      timeout: 10 * 1000,
      skipAddingFootprint: true,
      secretKey: Constants.TokenAdminSecretKey,
      sorobanContext,
    }
  );
  console.debug(paymentResult);
  sorobanContext.connect();
} catch (err) {
  console.log("Error while minting the token: ", err);
  console.error(err);
}
```

This block is where the actual token minting occurs. It's wrapped in a `try-catch` block, ensuring that any errors during the minting process are caught and handled appropriately, preventing the application from crashing and giving us a chance to provide feedback to the user.

The `await` keyword pauses the execution of the function until the promise returned by `sendTransaction` resolves. `sendTransaction` is a function obtained from our `useSendTransaction` hook, and it builds and sends a payment operation to the Stellar network.

The `sendTransaction` method accepts two arguments: a `TransactionBuilder` instance and an options object. The `TransactionBuilder` sets up the details of the transaction, such as the source account, network passphrase, transaction fee, and operations to be performed—in this case, a payment operation.

If the transaction is successful, `paymentResult` contains the result, which we log for debugging purposes. If an error occurs during the transaction, the function throws an error, which we catch and log.


## Wallet Integration: Freighter

Freighter is a browser extension that allows users to securely store their Stellar accounts and sign transactions. It's a convenient way to manage your Stellar accounts and interact with the Stellar network.

In the sample Crowdfund dapp, the `WalletData` component, located in `components/molecules/wallet-data/index.tsx`, plays a key role in wallet integration. Let's break down the code and understand its functionality:

```tsx
import React from "react";
import { DropdownSvg } from "../../../assets/icons";
import { useAccount, useIsMounted, useNetwork } from "../../../wallet";
import { ConnectButton } from "../../atoms";
import styles from "./style.module.css";
import Image from "next/image";

export function WalletData() {
  const mounted = useIsMounted();
  const { data: account } = useAccount();
  const { activeChain: chain, chains } = useNetwork();
  const unsupportedChain = chain?.unsupported;

  return (
    <>
      {mounted && account ? (
        <div className={styles.displayData}>
          {chain && (chains.length > 1 || unsupportedChain) && (
            <div className={styles.card}>
              {chain.iconUrl && (
                <Image
                  alt={chain.name ?? "Chain icon"}
                  style={{
                    background: chain.iconBackground,
                  }}
                  height="24"
                  src={chain.iconUrl}
                  width="24"
                />
              )}
              {chain.name ?? chain.id}
            </div>
          )}
          <div className={styles.card}>{account.displayName}</div>
        </div>
      ) : (
        <ConnectButton label="Connect Wallet" />
      )}
    </>
  );
}
```

Here's a breakdown of the code:

- The `mounted` variable is obtained using the `useIsMounted` hook, indicating whether the component is currently mounted or not.

- The `useAccount` hook is used to fetch the user's account data, and the `data` property is destructured from the result.

- The `useNetwork` hook is employed to access information about the active blockchain network and available chains. The activeChain and chains properties are destructured from the result.

- The `unsupportedChain` variable checks if the active chain is unsupported.

- Conditional rendering is used to display different content based on the component's mount status and the availability of account data.

- If the component is mounted and the account data is available, the user's wallet data is displayed. This includes the chain icon (if available), obtained from chain.iconUrl, and the chain name or ID. The account's display name is also shown.

- If there are multiple chains available or the active chain is unsupported, a chain card with the chain icon and name (or ID) is displayed.

- If the component is not mounted or the account data is not available, a `ConnectButton` component is rendered, allowing the user to connect their wallet.

## Conclusion

React offers a host of high-level concepts that can drastically improve your web development process. By understanding and utilizing these concepts—such as components, prop passing, state management, asynchronous operations, and error handling—you can create scalable, maintainable, and efficient applications.

Remember, the key to mastering React is practice. So, keep building and experimenting!