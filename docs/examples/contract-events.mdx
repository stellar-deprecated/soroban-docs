---
sidebar_position: 4
title: Contract Events
---

The [events example] demonstrates how to publish contract events. 

[events example]: https://github.com/stellar/soroban-examples/tree/main/events

## Run the Example

First go through the [Setup] process to get your development environment
configured, then clone the examples repository:

[Setup]: ../getting-started/setup.mdx

```
git clone https://github.com/stellar/soroban-examples
```

To run the tests for the example, navigate to the `events` directory, and use `cargo test`.

```
cd events
cargo test
```

You should see the output:

```
running 1 test
test test::test ... ok
```

## Code

```rust title="events/src/lib.rs"
#![no_std]
use soroban_sdk::{contractimpl, map, symbol, Env, Symbol};

pub struct EventsContract;

#[contractimpl]
impl EventsContract {
    pub fn hello(env: Env, to: Symbol) -> () {
        let events = env.events();
        let topics = (symbol!("Hello"), to);
        let data = map![&env, (1u32, 2u32)];
        events.publish(topics, data);
    }
}
```
Ref: https://github.com/stellar/soroban-examples/tree/main/events

## How it Works

This example contract is similar to the [hello world example]. It also contains one 
contract function named `hello`. However, instead of returning the greeting message to the caller, it 
publishes the message (along with some data) as a contract event.

[hello world example]: https://github.com/stellar/soroban-examples/tree/main/hello_world

### Contract Event

Contract events are introduced in "[CAP-56: Smart Contract Events]", which lets smart contract developers to 
emit information about what their contract is doing. 
[CAP-56: Smart Contract Events]: https://github.com/stellar/stellar-protocol/blob/master/core/cap-0056.md

```rust
let events = env.events();
```
creates an `Events` object through the environment, which facilitates publishing of new contract events. 


#### topics and data
An event may contain up to four topics, each topic can be any type except:
- `Vec`
- `Map`
- `Bytes` longer than 32 bytes
- `[contracttype]`

In addition, an event also contains a data object of any value or type including types defined by contracts using `[contracttype]`.

```rust
let topics = (symbol!("Hello"), to);
let data = map![&env, (1u32, 2u32)];
```
Here we specify two topics of `Symbol` type consist of our greeting message, and a data made of a small map. 

:::info
The topics don't have to be made of the same type. You can mix different types as long as the total topic count stays below the limit. 
:::

### Publish Event
```rust
events.publish(topics, data);
```
publishes a new contract event from previously defined `topics` and `data`. The function returns empty on success and traps on failure. 
Possible failure reasons can include malformed inputs (e.g. topic count exceeds limit) and running over the resource budget (TBD).
Once successfully published, the new event will stay in the [host environment]. 

[host environment]: http://localhost:3000/docs/learn/high-level-overview#host-environment

## Build the Contract

To build the contract, use the `cargo build` command.

```sh
cargo build --target wasm32-unknown-unknown --release
```

A `.wasm` file should be outputted in the `../target` directory:

```
../target/wasm32-unknown-unknown/release/soroban_events_contract.wasm
```

## Run the Contract

If you have [`soroban-cli`] installed, you can invoke contract functions in the
using it.

```sh
soroban-cli invoke \
    --wasm ../target/wasm32-unknown-unknown/release/soroban_events_contract.wasm \
    --id 1 \
    --fn hello \
    --arg friend
```

The following output should occur using the code above.

```json
null
Event #0:
{"ext":"v0","contractId":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],"type":"contract","body":{"v0":{
    "topics":[{"symbol":[72,101,108,108,111]},{"symbol":[102,114,105,101,110,100]}],
    "data":{"object":{"map":[{"key":{"u32":1},"val":{"u32":2}}]}}}}}%  
```

The `null` just indicates the `hello` contract function returned empty (which means success). 
It also retrieves one event `Event #0`, which is the contract event we previously published. 
To examine it further, we see the event consists of two topics, each a `symbol` (displayed as bytes), and a data object consist of a `map`. 
