---
sidebar_position: 18
title: State Expiration
description: State Expiration Semantics
---

# State Expiration

Contract data is made up of three different types: `Persistent`, `Temporary`, and `Instance`. In a contract, these are accessed with `env.storage().persistent()`, `env.storage().temporary()`, and `env.storage().instance()` respectively; see the [`storage()` docs](https://docs.rs/soroban-sdk/latest/soroban_sdk/storage/struct.Storage.html).

All contract data has a "lifetime" that must be periodically bumped. If an entry's lifetime is not periodically bumped, the entry will eventually reach the end of its lifetime and "expire". Each type of storage functions similarly, but have different fees and expiration behavior:

- When a `Temporary` entry expires, it is deleted from the ledger and is permanently inaccessible.
- When a `Persistent` or `Instance` entry expires, it is inaccessible, but can be "restored" and used again via the [`RestoreFootprintOp`].

## Contract Data Type Descriptions

The general usage and interface is identical for all storage types. They differ only in fees and expiration behavior as follows:

### `Temporary`

- Cheapest fees.
- Permanently deleted on expiration, cannot be restored.
- Suitable for time bounded data (i.e. price oracles, signatures, etc.) and easily recreateable data.
- Unlimited amount of storage.

### `Instance`

- Most expensive fees (same price as `Persistent` storage).
- Recoverable after expiration, can be restored using the [`RestoreFootprintOp`] operation.
- Shares the same lifetime as the contract instance. If the contract instance has not expired, instance data is guaranteed to be accessible and not expired.
- Limited amount of storage available.
- Suitable for "shared" contract state that cannot be `Temporary` (i.e. admin accounts, contract metadata, etc.).

### `Persistent`

- Most expensive fees (same price as `Instance` storage).
- Recoverable after expiration, can be restored using the [`RestoreFootprintOp`] operation.
- Does not share the same lifetime as the contract instance. If the contract instance is not expired, `Persistent` data may be expired and need to be restored before invoking the contract.
- Unlimited amount of storage.
- Suitable for user data that cannot be `Temporary` (i.e. balances).

## Contract Data Best Practices

As a general rule, `Temporary` storage should only be used for data that can be easily recreated or is only valid for a period of time, where `Persistent` or `Instance` storage should be used for data that cannot be recreated and should be kept permanently, such as a user's token balance.

Each storage type is in a separate key space. To demonstrate this, see the code snippet below:

```rust
const EXAMPLE_KEY: Symbol = symbol_short!("KEY");
env.storage().persistent().set(&EXAMPLE_KEY, 1);
env.storage().temporary().set(&EXAMPLE_KEY, 2);

env.storage().persistent().get(&EXAMPLE_KEY); // Returns Ok(1)
env.storage().temporary().get(&EXAMPLE_KEY); // Returns Ok(2)
```

All `Instance` storage is stored in a single contract instance `LedgerEntry` and shares a single lifetime. This means that one call to `Env.storage().instance().bump()` will extend the lifetime of all `Instance`
entries, as well as the contract instance itself. For `Temporary` and `Persistent` storage, each entry has its own lifetime and must be bumped individually. The interface is slightly different and takes the key
of the entry being bumped as well as the new lifetime.

A call to `bump(N)` ensures that the current lifetime of the contract instance entry is _at least_ N ledgers. For example, if `bump(100)` is called and the contract instance entry has a current lifetime of 50 ledgers, the lifetime will be extended to 100 ledgers. If `bump(100)` is called and the contract instance entry has a current lifetime of 150 ledgers, the lifetime will not be extended and the `bump()` call is a no-op.

In addition to contract defined lifetime extensions using the `bump()` function, a contract data entry's lifetime can be extended via the [`BumpFootprintExpirationOp`] operation.

## Terms and Semantics

### Expiration Ledger

Each `ContractData` and `ContractCode` entry has an `expirationLedger` field stored in its `LedgerEntry`.
The entry is considered expired when `current_ledger > expirationLedger`.

### Lifetime

An entry's lifetime is defined as how many ledgers remain until the entry expires.
For example, if the current ledger is 5 and an entry's expiration ledger is 15, then
the entry's lifetime is 10 ledgers.

### Minimum Lifetime

For each entry type, there is a minimum lifetime that the entry must have when being created
or updated. This lifetime minimum is enforced automatically at the protocol level. This minimum
is a network parameter and defaults to 16 ledgers for `Temporary` entries and 4,096 ledgers for
`Persistent` and `Instance` entries.

### Maximum Lifetime

On any given ledger, an entry's lifetime can be extended up to the maximum lifetime. This is a
network parameter and defaults to 1 year worth of ledgers. This maximum lifetime is not enforced
based on when an entry was created, but based on the current ledger. For example, if an entry is
created on January 1st, 2024, its lifetime could initially be bumped up to January 1st, 2025.
After this initial lifetime bump, if the entry received another lifetime bump later on January 10th, 2024,
the lifetime could be extended up to January 10th, 2025.

## Operations

### BumpFootprintExpirationOp

#### Semantics

XDR:

```
/*
    Threshold: med
    Result: BumpFootprintExpirationResult
*/
struct BumpFootprintExpirationOp
{
    ExtensionPoint ext;
    uint32 ledgersToExpire;
};
```

`BumpFootprintExpirationOp` is a Soroban operation that will bump the expiration
ledger of the entries specified in the _read-only set of the footprint_. The
read-write set must be empty. The bump will make sure that the entries will not
expire before ledgersToExpire ledgers from now.

Let's look at this example below.

```
Ex. Last closed ledger (LCL) = 5, Current Ledger = 6, ledgersToExpire = 8

entry1.expirationLedger = 10
entry2.expirationLedger = 14
entry3.expirationLedger = 10000

entry1.expirationLedger will be updated to 14 so it will live for 8 more ledgers
after the current one closes and the entry can be accessed in ledgers [6, 14]. Note: This is going to be updated to count
Current Ledger, so it'll become [6, 13].

entry2 and entry3 will not be updated because they already have an
expirationLedger that is large enough.
```

#### Transaction resources

`BumpFootprintExpirationOp` is a Soroban operation, and therefore must be the
only operation in a transaction. The transaction also needs to populate
`SorobanTransactionData` transaction extension explained
[here](../fundamentals-and-concepts/invoking-contracts-with-transactions.mdx#transaction-resources). To fill
out `SorobanResources`, use preflight mentioned in the provided link, or make
sure `readBytes` includes the key and entry size of every entry in the
`readOnly` set and make sure `extendedMetaDataSizeBytes` is at least double of
`readBytes`.

### RestoreFootprintOp

XDR:

```
/*
    Threshold: med
    Result: RestoreFootprintOp
*/
struct RestoreFootprintOp
{
    ExtensionPoint ext;
};
```

`RestoreFootprintOp` is a Soroban operation that will restore expired entries
specified in the _read-write set of the footprint_ and make them accessible
again. The read-only set of the footprint must be empty. An expired entry is one
where its expirationLedger is less than the current ledger number.

The restored entry will have its expiration ledger bumped to the [minimums] the
network allows for newly created entries, which is 4096 + current ledger for
persistent entries, and 16 + current ledger for temporary entries (Note that
both will be updated soon to use 4096 + current ledger - 1 and 16 + current
ledger - 1). The minimums linked are what the settings will be on release, but
they can be updated in the future through a validator vote.

[minimums]: https://github.com/stellar/stellar-core/blob/2109a168a895349f87b502ae3d182380b378fa47/src/ledger/NetworkConfig.h#L77-L78

#### Transaction resources

`RestoreFootprintOp` is a Soroban operation, and therefore must be the only
operation in a transaction. The transaction also needs to populate
`SorobanTransactionData` transaction extension explained
[here](../fundamentals-and-concepts/invoking-contracts-with-transactions.mdx#transaction-resources). To fill
out `SorobanResources`, use preflight mentioned in the provided link, or make
sure `writeBytes` includes the key and entry size of every entry in the
`readWrite` set and make sure `extendedMetaDataSizeBytes` is at least double of
`writeBytes`.

---

## Examples

We've done our best to build tooling around state expiration in the JavaScript SDK to make it easier to deal with, and this set of examples demonstrates how to leverage it.

### Overview

Both restoring and bumping the expiration of ledger entries follows a multi-step process regardless of their nature (contract data, instances, etc.):

1. First, **identify the ledger entries**. This usually means acquire them from a Soroban RPC server as part of your initial transaction simulation (see the [preflight docs](https://soroban.stellar.org/docs/fundamentals-and-concepts/interacting-with-contracts#preflight) and the [`simulateTransaction`](https://soroban.stellar.org/api/methods/simulateTransaction) method).

2. Then, **prepare your operation**. This means describing the ledger entries within the corresponding operation (i.e. `bumpFootprintOp` or `restoreFootprintOp`) and its ledger footprint (the `SorobanTransactionData` field), then simulating it to fill out fee and resource usage information.

3. Finally, **submit the transaction** and start again with what you were trying to do in the first place.

Each of the examples below will follow a structure like this. We'll work our way through three different scenarios:

- my contract instance expired
- the contract data containing the WASM representing the contract expired
- a piece of persistent data in my contract expired

Remember, though, that **any** combination of these scenarios can occur in reality.

### Preparation

To start off, we'll assume the following:

- you have created and funded account on the Soroban Futurenet
- you've built and deployed the `increment` contract from the [Soroban examples](https://github.com/stellar/soroban-examples/blob/main/increment/src/lib.rs) using that account

#### Preamble

In order to help the scaffolding of the code, we'll introduce some reusable components. The following is a simple, rudimentary looping mechanism to submit a transaction to Soroban RPC and wait for a result:

```typescript
import {
  Server,
  SorobanRpc,
  Transaction,
  FeeBumpTransaction,
} from "soroban-client";

const RPC_SERVER = "https://rpc-futurenet.stellar.org/";
const s = new Server(RPC_SERVER);

async function yeetTx(
  tx: Transaction | FeeBumpTransaction,
): Promise<SorobanRpc.GetTransactionResponse> {
  return s.sendTransaction(tx).then(async (reply) => {
    if (reply.status !== "PENDING") {
      throw reply;
    }

    let status;
    let attempts = 0;
    while (attempts++ < 5) {
      const tmpStatus = await s.getTransaction(reply.hash);
      switch (tmpStatus.status) {
        case "FAILED":
          throw tmpStatus;
        case "NOT_FOUND":
          await sleep(500);
          continue;
        case "SUCCESS":
          status = tmpStatus;
          break;
      }
    }

    if (attempts >= 5 || !status) {
      throw new Error(`Failed to find transaction ${reply.hash} in time.`);
    }

    return status;
  });
}

function sleep(ms: number) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
```

Remember: You should always handle errors gracefully! This is a fail hard and fail fast approach for the purposes of the examples.

### Example: My data expired!

We'll start with the simplest, most-likely occurrence: my piece of persistent data expired off of the ledger because I haven't interacted with my contract in a while. How do I get it back?

We'll assume that you don't know how that piece of data is represented on the ledger. If you know it, you can skip the steps where we figure that out. For now, this process is quite arduous (all the more reason to keep your data fresh and live!):

1. First, we identify ledger entries that need to be restored.
2. Second, we simulate a transaction with `restoreFootprintOp` to get fee info
3. Third, we actually run said transaction, ensuring those ledger entries are present in the `readWrite` footprint of the transaction (per [`RestoreFootprintOp`]).

After that, we can (simulate and) run our initial transaction again. Let's see that in code:

```typescript
import {
  BASE_FEE,
  Networks,
  Keypair,
  TransactionBuilder,
  SorobanDataBuilder,
  xdr,
} from "soroban-client";

// assume that `s` is the Server() instance from the preamble

function submitOrRestoreAndRetry(
  signer: Keypair,
  tx: Transaction,
): Promise<SorobanRpc.GetTransactionResponse> {
  return s
    .simulateTransaction(tx)
    .then((sim: SorobanRpc.GetTransactionResponse) => {
      if (resp.status !== "FAILED") {
        const prepTx = assembleTransaction(tx, Networks.FUTURENET, sim);
        prepTx.sign(signer);
        return yeetTx(prepTx);
      }

      //
      // This is our best-effort guess that failures are due to expired entries
      //
      if (!resp.error.includes("Error(Storage, MissingValue)")) {
        throw resp;
      }

      // extract the keys we used in our failed transaction
      const data = readSorobanData(sim.transactionData);
      const storageUsage = data.resources().footprint();

      //
      // Notice, we're blindly restoring all keys.
      //
      const ledgerKeys = storageUsage
        .readOnly()
        .concat(storageUsage.readWrite());
      return yeetRestoreTx(signer, ledgerKeys);
    })
    .then((resp: SorobanRpc.GetTransactionResponse) => {
      //
      // now that we've restored the necessary data, we can retry our tx
      //
      const retryTxBuilder = TransactionBuilder.cloneFrom(tx);

      // note that because we consumed a sequence number when restoring,
      // we need to make sure we set the correct value on this copy
      retryTxBuilder.source.incrementSequenceNumber();
      const retryTx = retryTxBuilder.build();
      retryTx.sign(signer);

      return yeetTx(retryTx);
    });
}

function yeetRestoreTx(
  signer: Keypair,
  ...ledgerKeys: xdr.LedgerKey[]
): Promise<SorobanRpc.GetTransactionResponse> {
  return s
    .getAccount(signer.publicKey())
    .then(async (account) => {
      const tx = new TransactionBuilder(account, {
        fee: BASE_FEE,
        networkPassphrase: Networks.FUTURENET,
        sorobanData: new SorobanDataBuilder().setReadWrite(ledgerKeys).build(),
      })
        .addOperation(Operation.restoreFootprint({}))
        .setTimeout(15)
        .build();

      return {
        tx,
        simData: await s.simulateTransaction(tx, tx.networkPassphrase),
      };
    })
    .then(({ tx, simData }) => {
      //
      // use the fee data but overwrite the storage usage to ensure we ONLY
      // keep our keys in the read-write section
      //
      const preppedTx = TransactionBuilder.cloneFrom(tx, {
        sorobanData: new SorobanDataBuilder(simData.transactionData)
          .setFootprint([], ledgerKeys)
          .build(),
      }).build();

      return yeetTx(preppedTx);
    });
}
```

Notice some quirks in the above code:

- If simulation fails, we rely on a specific error string as a _hint_ (not a guarantee) that we may be trying to use expired entries.
- Even with that error, we don't know _which_ entries are the expired ones, so we will blindly try restoring all of them (by taking the union of the read-only and read-write keys).

Both of these oddities should go away in future iterations of the Soroban platform and RPC server schema. We _could_ find out which specific ones expired by calling [`getLedgerEntries()`](https://soroban.stellar.org/api/methods/getLedgerEntries), then parsing each resulting entry to find its `expirationLedgerSeq`, but this is an extra round-trip:

```typescript
const expiredLedgerKeys = await s
  .getLedgerKeys(ledgerKeys)
  .then((resp: SorobanRpc.GetLedgerEntriesResponse) =>
    ledgerKeys.filter((ledgerKey, idx) => {
      const entry = xdr.LedgerEntryData.fromXDR(
        resp.entries[idx].xdr,
        "base64",
      );

      return (
        entry.switch() === xdr.LedgerEntryType.contractData() &&
        entry.contractData().expirationLedgerSeq() <= resp.latestLedger
      );
    }),
  );
```

Pick your poison: higher fees due to more storage access, or higher latency due to an extra roundtrip.

### Example: My contract expired!

As you can imagine, if the ledger cannot find your deployed contract instance or the code that backs it, it can't load it to execute your invocations Remember, there's a distinct, one-to-many relationship on the chain between a contract's code and deployed instances of that contract:

    +----------------+
    |                |
    |   my instance  |-------------\
    |                |              \           +---------------+
    +----------------+               \          |               |
                                      ------->  | contract WASM |
    +----------------+               /          |               |
    |                |              /           +---------------+
    | your instance  |-------------/
    |                |
    +----------------+

We need **both** to stay on the ledger for our contract calls to work.

Let's work through how these can be recovered. They are slightly different for a convenient reason: we don't need simulation to figure out the footprints, though you still can do it that way. Instead, we can leverage [`Contract.getFootprint()`](https://stellar.github.io/js-soroban-client/Contract.html#getFootprint), which prepares a footprint:

```typescript
import { Contract, Keypair } from "soroban-client";

function restoreContract(
  signer: Keypair,
  c: Contract,
): Promise<SorobanRpc.GetTransactionResponse> {
  return yeetRestoreTx(signer, c.getFootprint());
}
```

[`RestoreFootprintOp`]: #RestoreFootprintOp
[`BumpFootprintExpirationOp`]: #BumpFootprintExpirationOp
