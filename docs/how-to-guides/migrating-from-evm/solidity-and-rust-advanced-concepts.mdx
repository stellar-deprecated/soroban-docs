---
sidebar_position: 2
title: Advanced Smart Contract Concepts with Solidity and Rust
description: Learn advanced Solidity and Rust concepts and write safe and efficient smart contracts.
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

# Advanced Smart Contract Concepts with Solidity and Rust

In this tutorial, we will cover advanced Solidity and Rust concepts such as inheritance, interfaces, libraries, and modifiers. Additionally, we will learn how to write safe and efficient Rust code for smart contracts. Finally, we will learn how to convert common Solidity concepts to Rust.

## Table of Contents

1. [Advanced Solidity Concepts](#advanced-solidity-concepts)
2. [Advanced Rust Concepts](#advanced-rust-concepts)
3. [Writing Safe and Efficient Rust Code for Smart Contracts](#writing-safe-and-efficient-rust-code-for-smart-contracts)
4. [Solidity to Rust: Common Concepts, and Best Practices](#solidity-to-rust-common-concepts-and-best-practices)

## Advanced Solidity Concepts

### Inheritance

In Solidity, smart contracts can inherit properties and functions from other contracts. This is achieved using the `is` keyword.

Here is an example of a parent contract that defines a function called `messageFromParent` that returns a string:

```solidity
contract Parent {
    function messageFromParent() public pure returns (string memory) {
        return "Hello from Parent";
    }
}
contract Child is Parent {
    function messageFromChild(string memory newMessage) public pure returns (string memory) {
        string memory messageFromParent = messageFromParent();
        return string(abi.encodePacked(messageFromParent,', ', newMessage));
    }
}
```

In this example, the `Child` contract inherits the `messageFromParent` function from the `Parent` contract. The `Child` contract can then call the `messageFromParent` function directly.

### Interfaces

Interfaces are similar to contracts, but they cannot have any function implementations. They only contain function signatures. Contracts can implement interfaces using the `is` keyword, similar to inheritance.

Here is example of an interface that defines a function called `doSomething` that returns a `uint256`:

```solidity
interface SomeInterface {
    function doSomething() external returns (uint256);
}

contract SomeContract is SomeInterface {
    uint256 private counter;

    function doSomething() external override returns (uint256) {
        counter += 1;
        return counter;
    }
}
```

In this example, the `SomeContract` contract implements the `SomeInterface` interface. It's implementation returns a `u256` that is incremented each time the `doSomething` function is called.

### Libraries

Libraries are similar to contracts, but they cannot have any state variables. They are used to store reusable code that can be used by other contracts. Libraries are deployed once and can be used by multiple contracts. They are defined using the `library` keyword. They are invoked by using the `using` keyword.

```solidity
library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "Addition overflow");

        return c;
    }
}

contract MyContract {
    using SafeMath for uint256;

    uint256 public value;

    function increment(uint256 amount) public {
        value = value.add(amount);
    }
}
```

In this example, the `SafeMath` library is used in the `increment` function. The `increment` function uses the `add` function from the `SafeMath` library to increment the `value` variable.

### Modifiers

Modifiers are used to change the behavior of functions in a declarative way. They are defined using the `modifier` keyword. Modifiers can be used to perform common checks such as validating inputs, checking permissions, and more.

```solidity
contract Ownable {
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, "Caller is not the owner");
        _;
    }
}

contract MyContract is Ownable {
    function doSomething() public onlyOwner {
        // This function can only be called by the owner of the contract
    }
}
```

In this example, the `onlyOwner` modifier is used to restrict access to the `doSomething` function. The `doSomething` function can only be called by the `owner` of the contract which was defined during deployment as `msg.sender`.

## Advanced Rust Concepts

### Crates

A crate in Rust is a collection of precompiled programs, scripts, or routines that can be easily reused by programmers when writing code. This allows them to avoid reinventing the wheel by not having to implement the same logic or program multiple times. There are two types of crates in Rust: [Binary crates and Library crates](https://doc.rust-lang.org/book/ch07-01-packages-and-crates.html).

Binary crates are crates that can be executed as standalone programs. Library crates are crates that are meant to be used by other programs. Library crates can be imported into other programs using the `use` keyword.

Here is an example of a workflow that implements allocation (`alloc`) logic within a smart contract:

First a user would include the `alloc` crate in their `Cargo.toml` file:

```toml
[dependencies]
soroban-sdk = { workspace = true, features = ["alloc"] }

[dev_dependencies]
soroban-sdk = { workspace = true, features = ["testutils", "alloc"] }
```

Then they would import the `alloc` crate into their smart contract:

```rust
// Imports
#![no_std]
use soroban_sdk::{contractimpl, Env};

extern crate alloc;

pub struct AllocContract;

#[contractimpl]
impl AllocContract {
    /// Allocates a temporary vector holding values (0..count), then computes and returns their sum.
    pub fn sum(_env: Env, count: u32) -> u32 {
        let mut v1 = alloc::vec![];
        (0..count).for_each(|i| v1.push(i));

        let mut sum = 0;
        for i in v1 {
            sum += i;
        }

        sum
    }
}
```

In this example, the `alloc` crate is imported into the smart contract using the `extern crate alloc;` statement. The `alloc` crate is then used to create a temporary vector that holds values from 0 to `count`. The values in the vector are then summed and returned.

For more details on how to use the `alloc` crate, including a hands on practical exercise, visit the [alloc section](../../how-to-guides/alloc#how-it-works) of the documentation.

#### Inheriting Functionality from Other Crates

We can illustrate another example of inheritance by importing functionality into a crate from other crates in the same project in the following example:

Below is a function from the [`event.rs`](https://github.com/stellar/soroban-examples/blob/main/token/src/event.rs) file from our [Token](https://github.com/stellar/soroban-examples/tree/main/token) example.

```rust
use soroban_sdk::{Address, Env, Symbol};
...
pub(crate) fn mint(e: &Env, admin: Address, to: Address, amount: i128) {
    let topics = (Symbol::short("mint"), admin, to);
    e.events().publish(topics, amount);
}
```

This function will publish a mint event to the blockchain with the following output:

```
Emit event with topics = ["mint", admin: Address, to: Address], data = [amount: i128]
```

We'll also use a function from our [`admin.rs`](https://github.com/stellar/soroban-examples/blob/main/token/src/admin.rs) file.

```rust
// Metering: covered by components
pub fn read_administrator(e: &Host) -> Result<Address, HostError> {
    let key = DataKey::Admin;
    let rv = e.get_contract_data(key.try_into_val(e)?)?;
    Ok(rv.try_into_val(e)?)
}
```

This function returns a `Result` object that contains the administrator's address.

Lastly, we'll implement a function from our [`balance.rs`](https://github.com/stellar/soroban-examples/blob/main/token/src/balance.rs) file.

```rust
pub fn receive_balance(e: &Env, addr: Address, amount: i128) {
    let balance = read_balance(e, addr.clone());
    if !is_authorized(e, addr.clone()) {
        panic!("can't receive when deauthorized");
    }
    write_balance(e, addr, balance + amount);
}
```

This function writes an amount to an address' balance.

The `event.rs` is imported into the [`contract.rs`](https://github.com/stellar/soroban-examples/blob/main/token/src/contract.rs) file which holds the logic for our token contract.

```rust
//contract.rs

//imports
use crate::event;
use crate::admin::{read_administrator};
use crate::balance::{receive_balance};

// trait logic
pub trait TokenTrait {
fn mint(e: Env, to: Address, amount: i128);
}

// struct logic
pub struct Token;

// impl logic

#[contractimpl]
impl TokenTrait for Token {
fn mint(e: Env, to: Address, amount: i128) {
        check_nonnegative_amount(amount);
        let admin = read_administrator(&e);
        admin.require_auth();
        receive_balance(&e, to.clone(), amount);
        event::mint(&e, admin, to, amount);
    }
}
```

As you can see, the `event.rs`, `admin.rs`, and `balance.rs` files are imported into the `contract.rs` file using the `use` keyword. This allows us to use the functions from those files in the `mint` function of our `contract.rs` file.

#### Inheriting Functionality using `contractimport!`

The Soroban Rust SDK provides a powerful macro, [`contractimport`](https://docs.rs/soroban-sdk/latest/soroban_sdk/macro.contractimport.html), which allows a user to import a contract from its WASM file, generating a client, types, and constant holding the contract file.

Here is an example of how to use the `contractimport` macro taken from the [token.rs](https://github.com/stellar/soroban-examples/blob/main/liquidity_pool/src/token.rs) file from our [Liqudity Pool example](https://github.com/stellar/soroban-examples/blob/main/liquidity_pool):

First, we see that the wasm file from the [previously built token example](https://github.com/stellar/soroban-examples/blob/main/token)is imported into the `token.rs` file using the `contractimport` macro:

```rust
//token.rs
soroban_sdk::contractimport!(
    file = "../token/target/wasm32-unknown-unknown/release/soroban_token_contract.wasm"
);
```

We see then that our token contract is imported into our [`lib.rs`](https://github.com/stellar/soroban-examples/blob/main/liquidity_pool/src/lib.rs) file and a `Client` is generated for us to access functionality from the token contract:

```rust
//lib.rs
mod token;

fn get_balance(e: &Env, contract_id: BytesN<32>) -> i128 {
    token::Client::new(e, &contract_id).balance(&e.current_contract_address())
}

fn transfer(e: &Env, contract_id: BytesN<32>, to: Address, amount: i128) {
    token::Client::new(e, &contract_id).transfer(&e.current_contract_address(), &to, &amount);
}

struct LiquidityPool;

#[contractimpl]
impl LiquidityPoolTrait for LiquidityPool {
let token_a_client = token::Client::new(&e, &get_token_a(&e));
}
```

In the above example, we use `contractimport` to interact with the token file via a `Client` that was generated for the `token` module. This `Client` was created using a Contract trait that matches the interface of the contract, a ContractClient struct that contains functions for each function in the contract, and types for all contract types defined in the contract.

### Modules

In Rust, modules consist of a cohesive set of related functions and types that are often organized together for better organization and reusability. These modules can be reused across multiple projects by publishing them as crates.

Here is an example of a module that implements `SafeMath` logic with an `add` function:

```rust
#![no_std]

mod safe_math

// mod safe_math {
//     pub fn add(a: u32, b: u32) -> Result<u32, &'static str> {
//          a.checked_add(b).ok_or("Addition overflow")
//      }
// }


// Imports
use soroban_sdk::{contractimpl, Env};
use safe_math::add;

pub trait MathContract {
    fn add(&self, env: Env, a: u32, b: u32) -> u32;
}

pub struct Adder;

impl MathContract for Adder {
    fn add(&self, _env: Env, a: u32, b: u32) -> u32 {
        add(a, b)
    }
}

#[contractimpl]
impl Adder {}

// test module
#[cfg(test)]
mod test;
```

Notice that we use the `checked_add` function from the standard library to ensure that the addition does not overflow. This is important because if the addition overflows, it could lead to unexpected behavior in the contract.

Even when Rust code is compiled with the `#![no_std]` flag, it is still possible to use some of the standard library's features, such as the `checked_add` function. This is because Rust provides the option to selectively import modules and functions from the standard library, allowing developers to use only the specific features they need.

### Traits

Rust does not have a built-in modifier system like Solidity. However, you can achieve similar functionality using `traits` and their implementations.

In the example below, we will illustrate the inherticance of traits using the `Ownable` trait.

```rust
#![no_std]

// Imports
use soroban_sdk::{contracttype, Address};

// Define the `Ownable` trait
trait Ownable {
    fn is_owner(&self, owner: &Address) -> bool;
}

// Implement the `Ownable` trait for the `OwnableContract` struct
impl Ownable for OwnableContract {
    fn is_owner(&self, owner: &Address) -> bool {
        self.owner == *owner
    }
}

// Define a modifier that requires the caller to be the owner of the contract
fn only_owner(contract: &OwnableContract, owner: &Address) -> bool {
    contract.is_owner(owner)
}

// Implement the contract for the `OwnableContract` struct
#[contracttype]

// Define the `OwnableContract` struct
pub struct OwnableContract {
    owner: Address,
    number: u32,
}

impl OwnableContract {
    // Define a public method that requires the caller to be the owner of the contract
    pub fn change_number(&mut self, new_number: u32) {
        if only_owner(self, &self.owner) {
            self.number = new_number;
        }
    }
}

#[cfg(test)]
mod test;
```

Heres a breakdown of the code above:

- First, we define the `Ownable` trait, which defines a single method called `is_owner`. This method takes an `Address` as an argument and returns a boolean value indicating whether or not the address is the owner of the contract.
- Next, we implement the `Ownable` trait for the `OwnableContract` struct. This allows us to use the `is_owner` method on instances of the `OwnableContract` struct.
- Then, we define a "modifier" called `only_owner` that takes an instance of the `OwnableContract` struct and an `Address` as arguments. This "modifier" returns a boolean value indicating whether or not the address is the owner of the contract.
- Finally, we implement the contract for the `OwnableContract` struct. This allows only the `owner` of the contract to use the `change_number` method on instances of the `OwnableContract` struct.

It's worth mentioning that the Soroban Rust SDK comes with several built-in requirements that developers can use, such as the [`require_auth`](https://docs.rs/soroban-sdk/latest/soroban_sdk/struct.Address.html#method.require_auth) method provided by the `Address` struct.

### Interfaces

Interfaces are an essential part of building smart contracts with Soroban.

There are many types of smart contract interfaces, and each has a specific purpose. One example of an interface built with Soroban is the [Token Interface](../../reference/interfaces/token-interface). This interface ensures that tokens deployed on Soroban are interoperable with contracts built to support Soroban's built-in tokens. The Token Interface consists of three compatibility requirements:

- `function interface`
- `authorization`
- `events`

For more information on smart contract interfaces built with Soroban, including the Token Interface, visit the [interfaces section](../../category/interfaces) of the documentation.

## Writing Safe and Efficient Rust Code for Smart Contracts

When writing Rust code for smart contracts, it's important to focus on safety and efficiency. Some tips include:

- Use the [`Result`](https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html) type to to handle errors in a safe and predictable way. In smart contracts, it's important to avoid panicking, as this can lead to unpredictable behavior. Instead, Result can be used to handle errors and ensure that the contract behaves as expected.

In the example below, the `add` function returns a `Result` type, which can either be `Ok` or `Err`. If the addition does not overflow, the function returns `Ok`, otherwise it returns `Err`.

```rust
pub fn add(a: u32, b: u32) -> Result<u32, &'static str> {
    a.checked_add(b).ok_or("Addition overflow")
}
```

- Use the `checked_` family of functions, such as `checked_add`, `checked_sub`, etc., to perform arithmetic operations in a safe and efficient manner. These functions check for overflows and underflows and return an error if one occurs.

In the example below, the `add` function uses the `checked_add` function to perform the addition. If the addition overflows, the function returns an error.

```rust
pub fn add(a: u32, b: u32) -> u32 {
    a.checked_add(b).expect("Addition overflow")
}
```

- Use `cargo` and `clippy` to enforce code quality, style, and efficiency in Rust. `cargo` is Rust's package manager and provides a number of tools for building and testing Rust code. `clippy` is a linter that can help identify potential issues in the code, such as unused variables or functions that could be optimized.

To use clippy with cargo, you'll first need to install it. You can do this by running the following command in your terminal:

```zsh
cargo install clippy
```

Once clippy is installed, you can run it by running the following command in your terminal:

```zsh
cargo clippy
```

This will run clippy on your entire project, checking for potential issues and providing suggestions for improvement. Clippy will output any issues it finds, along with suggestions for how to fix them.

- Use `cargo` and `rustfmt` to enforce code style. `rustfmt` is a tool that can automatically format Rust code according to the Rust style guide. This can help ensure that the code is consistent and easy to read.

To use rustfmt with cargo, you'll first need to install it. You can do this by running the following command in your terminal:

```zsh
cargo install rustfmt
```

Once rustfmt is installed, you can run it by running the following command in your terminal:

```zsh
cargo fmt
```

Before:

```rust
fn main()
{
let x=5;
if x==5 {
println!("Hello, world!");
}
}
```

After:

```rust
fn main() {
    let x = 5;
    if x == 5 {
        println!("Hello, world!");
    }
}
```

## Solidity to Rust: Common Concepts and Best Practices

In this section we will explore key Solidity concepts and provide their Rust equivalents. We will discuss the following topics:

- Message Properties
- Error Handling
- Address-related functionality
- Function visibility specifiers
- Time-based variables

### Message Properties

The Soroban Rust SDK and Solidity provide a number of message properties that can be used to access information about the current transaction. These properties include:

#### Solidity

- `msg.sender`: The address of the account that sent the transaction.
- `msg.value`: The amount of Ether sent with the transaction.
- `msg.data`: The data sent with the transaction.

Here's a simple example of a smart contract that demonstrates the use of each

```solidity
pragma solidity ^0.8.0;

contract SimpleContract {
    address public sender;
    uint public value;
    bytes public data;

    // Caller must send Ether and data to this function.
    // This function will store the sender, value, and data.
    function sendData(bytes calldata _data) external payable {
        sender = msg.sender;
        value = msg.value;
        data = _data;
    }
}
```

These are a part of Solidity's global variables, which are accessible from any function in the contract.

#### Rust

In contrast to Solidity's global variables, Soroban relies on passing an [`Env`](https://docs.rs/soroban-sdk/0.7.0/soroban_sdk/struct.Env.html) argument to all functions which provides access to the environment the contract is executing within.

The `Env` provides access to information about the currently executing contract, who invoked it, contract data, functions for signing, hashing, etc.

For instance, you would use `env.storage().get(key)` to access a target value from the contract's [storage](https://docs.rs/soroban-sdk/0.7.0/soroban_sdk/storage/struct.Storage.html).

- `Env::storage` is used to get a struct for accessing and updating contract data that has been stored.
- Used as `env.storage().get()` or `env.storage().set()`.
- Additionally, we utilize the `clone()` method, a prevalent trait in Rust that allows for the explicit duplication of an object.

See the example below for implementations of `Env::storage()` and `clone()`

- `env.storage().set()`

```rust
use soroban_sdk::{Env, Symbol};

let storage = env.storage();
let key = Symbol::short("key");
env.storage().set(&key);
```

- `env.storage().get()`

```rust
use soroban_sdk::{Env, Symbol};

let storage = env.storage();
e.storage().get(&key);
```

- `clone()`

```rust
use soroban_sdk::{Env, Address};

pub fn return_user(env: Env, user: Address)
let user_address: Address = user.clone();
```

### Error Handling

The Soroban Rust SDK and Solidity provide a number of ways to handle errors. These include:

#### Solidity

Solidity provides a `require` function that can be used to check for certain conditions and revert the transaction if they are not met. For example, the following code sets a minimum value for the amount of Ether sent with the transaction:

```solidity

function deposit() public payable {
    require(msg.value >= 1 ether, "Not enough Ether sent");
    // ...
}
```

#### Rust

The [panic!](https://doc.rust-lang.org/book/ch09-00-error-handling.html) macro serves as Rust's error handling mechanism, which closely resembles the `require` function in Solidity.

```rust
fn deposit() {
        let deposit_amount = e.storage().get(&amount).unwrap();
        if deposit_amount < 1_000_000_000_000_000_000 {
            panic!(b"Not enough XLM sent");
        }
        // ...
    }
```

### Address-Related Functionality

The Soroban Rust SDK and Solidity provide a number of functions for working with addresses. These functions include:

#### Solidity

- `address(this)`: Returns the address of the current contract.
- `address payable(this)`: Returns the address of the current contract as a payable address.
- `address(address)`: Returns the address of the specified account.
- `address payable(address)`: Returns the address of the specified account as a payable address.

Below is an example of a smart contract that illustrates how contracts can be retrieved

```solidity
pragma solidity ^0.8.0;

contract SimpleContract {
    address public contractAddress = address(this);
    address public randomAddress = 0x1234567890123456789012345678901234567890;

    address public payableAddress = payable(address(this));
    address public payableRandomAddress = payable(0x1234567890123456789012345678901234567890);
}
```

There would be no diffrence in appearance between a regular address and a payable address in Solidity.

#### Rust

- `Env::get_current_contract_address()`: Returns the Address object corresponding to the current executing contract.
- Used as `e.current_contract_address()`
- `Env::get_current_contract_id()`: Returns the 32-byte hash identifier of the current executing contract.
- Used as `e.current_contract_id()`

The `Env` not only provides essential information about the currently executing contract and its invoker, but also offers access to contract data and functions for signing, hashing, and more. The construction or conversion of most types in Soroban requires access to an `Env` instance.

Here is an example of a smart contract that illustrates how contracts can be retrieved

```rust
#![no_std]
use soroban_sdk::{contractimpl, log, Address, Env, Symbol};

pub struct SimpleContract;

#[contractimpl]
impl SimpleContract {
    /// increment increments an internal counter, and returns the value.
    pub fn return_user(env: Env, user: Address) {
        let user_address: Address = user.clone();
        let user_contract_id = env.current_contract_address();
        let user_contract_address = env.current_contract_id();
    }
}
```

### Function Visibility Specifiers

The Soroban Rust SDK and Solidity provide a number of function visibility specifiers that can be used to control who can call a function. These specifiers include:

#### Solidity

- `public`: Anyone can call the function.
- `external`: Only other contracts can call the function.
- `internal`: Only the current contract and contracts that inherit from it can call the function.
- `private`: Only the current contract can call the function.

Here is an example of a smart contract that illustrates how function visibility is used in Solidity:

```solidity
pragma solidity ^0.8.0;

contract SimpleContract {
    function publicFunction() public {}
    function externalFunction() external {}
    function internalFunction() internal {}
    function privateFunction() private {}
}
```

#### Rust

- `pub`: The item (function, struct, etc.) is accessible from any module or scope.
- `pub(crate)`: The item is accessible only within the current crate.
- `pub(super)`: The item is accessible only within its parent module.
- `pub(in path::to::module)`: The item is accessible only within the specified module path.

Here is an example of a module that illustrates how function visibility is used in Rust:

```rust
mod outer {
    pub struct PublicStruct {
        pub field: u32,
    }

    pub(crate) struct CrateStruct {
        pub(crate) field: u32,
    }

    // This struct is private becuase it is not marked as `pub`.
    struct PrivateStruct {
        field: u32,
    }

    mod inner {
        pub(super) struct SuperStruct {
            pub(super) field: u32,
        }
    }

    pub fn public_function() {
        let public_struct = PublicStruct { field: 1 };
        let crate_struct = CrateStruct { field: 2 };
        let private_struct = PrivateStruct { field: 3 };
        let super_struct = inner::SuperStruct { field: 4 };
    }
}
```

### Time-Based Variables

The Soroban Rust SDK and Solidity provide a number of time-based variables that can be used to access information about the current block(EVM) or ledger(Soroban). These variables include:

#### Solidity

- `block.timestamp`: The timestamp of the current block.
- `block.number`: The number of the current block.

Here is an example of a smart contract that illustrates how time-based variables are used in Solidity:

```solidity
pragma solidity ^0.8.0;

contract SimpleContract {
    function getTimestamp() public view returns (uint256) {
        return block.timestamp;
    }

    function getBlockNumber() public view returns (uint256) {
        return block.number;
    }
}
```

#### Rust

- `Env::get_ledger_timestamp(self.env())`: Returns a unix timestamp for when the ledger was closed.
- Used as `env.ledger().timestamp()`
- `Env::get_ledger_sequence(self.env())`: Returns the sequence number of the ledger.
- Used as `env.ledger().sequence()`

Here is an example of a smart contract that illustrates how time-based variables are used in Rust:

```rust
#![no_std]
use soroban_sdk::{contractimpl, Address, Env};

pub struct SimpleContract;

#[contractimpl]
impl SimpleContract {
    pub fn get_timestamp(env: Env) {
        let timestamp = env.ledger().timestamp();
        let sequence = env.ledger().sequence();
    }
}
```

Overall the Rust equivalents of Solidity concepts are very similar. The main difference is that Rust uses `env` instead of `msg` to access information about the current transaction.

For more information on Solidity concepts and their Rust equivalents, it is recommend that one refer to both the [Soroban Rust SDK documentation](https://docs.rs/soroban-sdk/latest/soroban_sdk/struct.Env.html) and the [Solidity documentation](https://docs.soliditylang.org/en/v0.8.19/cheatsheet.html).
