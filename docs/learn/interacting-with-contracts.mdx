---
sidebar_position: 4
title: Interacting with contracts
---

## Three types of interactions

### Function call

A function call is the simplest and least expensive kind of contract
interaction. A function call does exactly what you would expect a contract call
to do in any other software development context: the contract transfers control
and data to another part of the _same_ contract. Because a function call always
transfers control to the same contract, they do not change the values returned
by `get_current_contract` and `get_invoking_contract`. A function call is the
only way to access the private methods of a contract.

To perform a function call, simply make a Rust function call.

### Contract invokation

A contract invokation is a more powerful and more expensive kind of contract
interaction. A contract invokation is similar to starting a new process because
the code that runs will be in a separate address space, meaning that they do
not share any data other than what was passed in the invokation. While a
contract invokation typically transfers control to a _different_ contract, it
is possible to transfer control to the currently running contract. Regardless
of whether the contract that receives control is a different contract or the
currently running contract, the value returned by `get_invoking_contract` will
be the previous value of `get_current_contract`. A contract invokation can only
access the public methods of a contract.

If a contract contains a public function `f`, then invoking `f` can be done by
making a Rust function call to `f::invoke`.

### Operation

An operation is the ultimate entrypoint of every contract interaction. An
operation transfers control and external data to a contract, allowing execution
to begin.

## Testing contracts with our testutils machinery

We provide some machinery in the Soroban
[SDK](https://github.com/stellar/rs-soroban-sdk) that allows a user to
test contract calls by writing rust test cases.

### Example

Let's look at the [single offer contract](https://github.com/stellar/soroban-examples/blob/main/single_offer/src/lib.rs) as an example -

```rust
#[contractimpl(export_if = "export")]
impl SingleOfferTrait for SingleOffer {
    fn initialize(e: Env, admin: Identifier, sell_token: U256, buy_token: U256, n: u32, d: u32) {
        ...
```

Notice the `contractimpl` procedural macro attribute. This attribute, along with
the `testutils` feature enabled, will allow the user to call a function in the
contract directly in a rust test case. For example, the single offer contract
has an alias `pub use crate::__initialize::call_internal as initialize` for the
`initialize` contract function, which is used
[here](https://github.com/stellar/soroban-examples/blob/56fef787395b5aed7cd7b19772cca28e21b3feb5/single_offer/src/testutils.rs#L45).
The rest of the `call_internal` aliases for the single offer contract can be
seen
[here](https://github.com/stellar/soroban-examples/blob/56fef787395b5aed7cd7b19772cca28e21b3feb5/single_offer/src/testutils.rs#L15)
in a `SingleOffer` wrapper class, and you can see how they're used in a [test
case](https://github.com/stellar/soroban-examples/blob/56fef787395b5aed7cd7b19772cca28e21b3feb5/single_offer/src/test.rs#L42).

This machinery can also be used to test multiple contracts together. For
example, the single offer contract test case creates a token using the
[token
contract](https://github.com/stellar/soroban-examples/blob/56fef787395b5aed7cd7b19772cca28e21b3feb5/single_offer/src/test.rs#L22).
