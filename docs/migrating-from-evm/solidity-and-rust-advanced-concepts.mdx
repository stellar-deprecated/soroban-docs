---
sidebar_position: 2
title: "Advanced Smart Contracts with Solidity, Rust, and Soroban"
description: "Learn advanced Solidity and Rust concepts, write safe and efficient Rust code, use Rust and Soroban for custom smart contract logic, and deploy and test in a local development environment."
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

# Advanced Smart Contracts with Solidity, Rust, and Soroban

In this tutorial, we will cover advanced Solidity and Rust concepts such as inheritance, interfaces, libraries, and modifiers. Additionally, we will learn how to write safe and efficient Rust code for smart contracts, use Rust and Soroban to develop custom smart contract logic, and deploy and test smart contracts in a local development environment.

## Table of Contents

1. [Advanced Solidity Concepts](#advanced-solidity-concepts)
2. [Advanced Rust Concepts](#advanced-rust-concepts)
3. [Writing Safe and Efficient Rust Code for Smart Contracts](#writing-safe-and-efficient-rust-code-for-smart-contracts)
4. [Solidity to Rust: Common Concepts, and Best Practices](#solidity-to-rust-common-concepts-and-best-practices)
5. [Using Rust and Soroban for Smart Contract Development](#rust-and-soroban)
6. [Vault Contract Deployment and Interaction](#vault-contract-deployment-and-interaction)

## Advanced Solidity Concepts

### Inheritance

In Solidity, smart contracts can inherit properties and functions from other contracts. This is achieved using the `is` keyword.

```javascript
contract Parent {
    function messageFromParent() public pure returns (string memory) {
        return "Hello from Parent";
    }
}
contract Child is Parent {
    function messageFromChild(string memory newMessage) public pure returns (string memory) {
        string memory messageFromParent = messageFromParent();
        return string(abi.encodePacked(messageFromParent,', ', newMessage));
    }
}
```

### Interfaces

Interfaces are similar to abstract contracts, but they cannot have any function implementations. They only contain function signatures. Contracts can implement interfaces using the `is` keyword, similar to inheritance.

```javascript
interface SomeInterface {
    function doSomething() external returns (uint256);
}

contract SomeContract is SomeInterface {
    uint256 private counter;

    function doSomething() external override returns (uint256) {
        counter += 1;
        return counter;
    }
}
```

### Libraries

Libraries are similar to contracts, but they cannot have any state variables. They are used to store reusable code that can be used by other contracts. Libraries are deployed once and can be used by multiple contracts. They are defined using the `library` keyword.

```javascript
library SafeMath {
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a, "Addition overflow");

        return c;
    }
}

contract MyContract {
    using SafeMath for uint256;

    uint256 public value;

    function increment(uint256 amount) public {
        value = value.add(amount);
    }
}
```

### Modifiers

Modifiers are used to change the behavior of functions in a declarative way. They are defined using the `modifier` keyword. Modifiers can be used to perform common checks such as validating inputs, checking permissions, and more.

```javascript
contract Ownable {
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, "Caller is not the owner");
        _;
    }
}

contract MyContract is Ownable {
    function doSomething() public onlyOwner {
        // This function can only be called by the owner of the contract
    }
}
```

## Advanced Rust Concepts

### Crates

A library in Rust is a collection of precompiled programs, scripts, or routines that can be easily reused by programmers when writing code. This allows them to avoid reinventing the wheel by not having to implement the same logic or program multiple times. In Rust, libraries are also known as crates. There are two types of crates in Rust: [Binary crates and Library crates](https://doc.rust-lang.org/book/ch07-01-packages-and-crates.html).

Binary crates are crates that can be executed as standalone programs. Library crates are crates that are meant to be used by other programs. Library crates can be imported into other programs using the `use` keyword.

Here is an example of a workflow that implements allocation (`alloc`) logic within a smart contract:

First a user would include the `alloc` crate in their `Cargo.toml` file:

```toml
[dependencies]
soroban-sdk = { workspace = true, features = ["alloc"] }

[dev_dependencies]
soroban-sdk = { workspace = true, features = ["testutils", "alloc"] }
```

Then they would import the `alloc` crate into their smart contract:

```rust
#![no_std]

// Imports
#![no_std]
use soroban_sdk::{contractimpl, Env};

extern crate alloc;

pub struct AllocContract;

#[contractimpl]
impl AllocContract {
    /// Allocates a temporary vector holding values (0..count), then computes and returns their sum.
    pub fn sum(_env: Env, count: u32) -> u32 {
        let mut v1 = alloc::vec![];
        (0..count).for_each(|i| v1.push(i));

        let mut sum = 0;
        for i in v1 {
            sum += i;
        }

        sum
    }
}
```

For more details on how to use the `alloc` crate, including a hands on practical exercise, visit the [alloc section](../how-to-guides/alloc#how-it-works) of the documentation.

### Modules

In Rust, modules consist of a cohesive set of related functions and types that are often organized together for better organization and reusability. These modules can be reused across multiple projects by publishing them as crates, which are essentially self-contained packages that can be easily imported into any Rust project.

Here is an example of a module that implements `SafeMath` logic with an `add` function:

```rust
#![no_std]

mod safe_math

// mod safe_math {
//     pub fn add(a: u32, b: u32) -> Result<u32, &'static str> {
//          a.checked_add(b).ok_or("Addition overflow")
//      }
// }


// Imports
use soroban_sdk::{contractimpl, Env};
use safe_math::add;

pub trait MathContract {
    fn add(&self, env: Env, a: u32, b: u32) -> u32;
}

pub struct Adder;

impl MathContract for Adder {
    fn add(&self, _env: Env, a: u32, b: u32) -> u32 {
        add(a, b)
    }
}

#[contractimpl]
impl Adder {}

// test module
#[cfg(test)]
mod test;
```

Notice that we use the `checked_add` function from the standard library to ensure that the addition does not overflow. This is important because if the addition overflows, it could lead to unexpected behavior in the contract.

Even when Rust code is compiled with the #![no_std] flag, it is still possible to use some of the standard library's features, such as the `checked_add` function. This is because Rust provides the option to selectively import modules and functions from the standard library, allowing developers to use only the specific features they need.

### Traits

Rust does not have a built-in modifier system like Solidity. However, you can achieve similar functionality using `traits` and their implementations.

```rust
#![no_std]

// Imports
use soroban_sdk::{contracttype, Address};

// Define the `Ownable` trait
trait Ownable {
    fn is_owner(&self, owner: &Address) -> bool;
}

// Implement the `Ownable` trait for the `OwnableContract` struct
impl Ownable for OwnableContract {
    fn is_owner(&self, owner: &Address) -> bool {
        self.owner == *owner
    }
}

// Define a modifier that requires the caller to be the owner of the contract
fn only_owner(contract: &OwnableContract, owner: &Address) -> bool {
    contract.is_owner(owner)
}

// Implement the contract for the `OwnableContract` struct
#[contracttype]

// Define the `OwnableContract` struct
pub struct OwnableContract {
    owner: Address,
    number: u32,
}

impl OwnableContract {
    // Define a public method that requires the caller to be the owner of the contract
    pub fn change_number(&mut self, new_number: u32) {
        if only_owner(self, &self.owner) {
            self.number = new_number;
        }
    }
}

#[cfg(test)]
mod test;
```

Heres a breakdown of the code above:

- First, we define the `Ownable` trait, which defines a single method called `is_owner`. This method takes an `Address` as an argument and returns a boolean value indicating whether or not the address is the owner of the contract.
- Next, we implement the `Ownable` trait for the `OwnableContract` struct. This allows us to use the `is_owner` method on instances of the `OwnableContract` struct.
- Then, we define a modifier called `only_owner` that takes an instance of the `OwnableContract` struct and an `Address` as arguments. This modifier returns a boolean value indicating whether or not the address is the owner of the contract.
- Finally, we implement the contract for the `OwnableContract` struct. This allows us to use the `change_number` method on instances of the `OwnableContract` struct.

It's worth mentioning that the Soroban SDK comes with several built-in requirements that developers can use, such as the [`require_auth`](https://docs.rs/soroban-sdk/latest/soroban_sdk/struct.Address.html#method.require_auth) method provided by the `Address` struct.

### Interfaces

Interfaces are an essential part of building smart contracts with the `Soroban SDK`.

There are many types of smart contract interfaces, and each has a specific purpose. One example of a smart contract interface built with `Soroban SDK` is the [Token Interface](../reference/interfaces/token-interface). This interface ensures that tokens deployed on Soroban are interoperable with contracts built to support Soroban's built-in tokens. The Token Interface consists of three compatibility requirements:

- `function interface`
- `authorization`
- `events`

For more information on smart contract interfaces built with Soroban SDK, including the Token Interface, visit the [interfaces section](../category/interfaces) of the documentation.

## Writing Safe and Efficient Rust Code for Smart Contracts

When writing Rust code for smart contracts, it's important to focus on safety and efficiency. Some tips include:

- Use the [`Result`](https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html) type to to handle errors in a safe and predictable way. In smart contracts, it's important to avoid panicking, as this can lead to unpredictable behavior. Instead, Result can be used to handle errors and ensure that the contract behaves as expected.

```rust
pub fn add(a: u32, b: u32) -> Result<u32, &'static str> {
    a.checked_add(b).ok_or("Addition overflow")
}
```

- Use the `checked_` family of functions, such as `checked_add`, `checked_sub`, etc., to perform arithmetic operations in a safe and efficient manner. These functions check for overflows and underflows and return an error if one occurs.

```rust
pub fn add(a: u32, b: u32) -> u32 {
    a.checked_add(b).expect("Addition overflow")
}
```

- Use `cargo` and `clippy` to enforcing code quality, style, and efficiency in Rust. `cargo` is Rust's package manager and provides a number of tools for building and testing Rust code. `clippy` is a linter that can help identify potential issues in the code, such as unused variables or functions that could be optimized.

To use clippy with cargo, you'll first need to install it. You can do this by running the following command in your terminal:

```zsh
cargo install clippy
```

Once clippy is installed, you can run it by running the following command in your terminal:

```zsh
cargo clippy
```

This will run clippy on your entire project, checking for potential issues and providing suggestions for improvement. Clippy will output any issues it finds, along with suggestions for how to fix them.

- Use `cargo` and `rustfmt` to enforce code style. `rustfmt` is a tool that can automatically format Rust code according to the Rust style guide. This can help ensure that the code is consistent and easy to read.

To use rustfmt with cargo, you'll first need to install it. You can do this by running the following command in your terminal:

```zsh
cargo install rustfmt
```

Once rustfmt is installed, you can run it by running the following command in your terminal:

```zsh
cargo fmt
```

Before:

```rust
fn main()
{
let x=5;
if x==5 {
println!("Hello, world!");
}
}
```

After:

```rust
fn main() {
    let x = 5;
    if x == 5 {
        println!("Hello, world!");
    }
}
```

## Solidity to Rust: Common Concepts and Best Practices

In this sectiopn we will explore key Solidity concepts and provide their Rust equivalents. We will discuss the following topics:

- Solidity message properties and their Rust equivalents
- Error Handling in Solidity and Rust
- Address-related functionality
- Function visibility specifiers
- Time-based variables

### Solidity Message Properties and Their Rust Equivalents

Solidity provides a number of message properties that can be used to access information about the current transaction. These properties include:

- `msg.sender`: The address of the account that sent the transaction.
- `msg.value`: The amount of Ether sent with the transaction.
- `msg.data`: The data sent with the transaction.

In contrast to Solidity's global variables, Soroban relies on passing an `Env` argument to all functions. For instance, you would use `env.storage().get(key)` to access storage. The `Env` type allows access to the environment in which the contract is executing.

- `Env::storage`: Get a [Storage](https://docs.rs/soroban-sdk/0.7.0/soroban_sdk/storage/struct.Storage.html) struct for accessing and update contract data that has been stored.
- Used as `Env::storage().get()` or `Env::storage().set()`.
- Additionally, we utilize the `clone()` method, a prevalent trait in Rust that allows for the explicit duplication of an object.

For example to get the sender address from a `fn` call:

```rust
// public function `increment` that takes an `Address` and a `u32` as arguments
pub fn increment(env: Env, user: Address, value: u32


let user_address: Address = user.clone();
```

### Error Handling in Solidity and Rust

Solidity provides a `require` function that can be used to check for certain conditions and revert the transaction if they are not met. For example, the following code sets a minimum value for the amount of Ether sent with the transaction:

```javascript

function deposit() public payable {
    require(msg.value >= 1 ether, "Not enough Ether sent");
    // ...
}
```

The [panic!](https://doc.rust-lang.org/book/ch09-00-error-handling.html) macro serves as Rust's error handling mechanism, which closely resembles the `require` function in Solidity.

```rust
fn deposit() {
        let deposit_amount = e.storage().get_unchecked(&DataKey::Deposit).unwrap();
        if deposit_amount < 1_000_000_000_000_000_000 {
            panic!(b"Not enough XLM sent");
        }
        // ...
    }
```

### Address-Related Functionality

Solidity provides a number of functions for working with addresses. These functions include:

- `address(this)`: Returns the address of the current contract.
- `address payable(this)`: Returns the address of the current contract as a payable address.
- `address(address)`: Returns the address of the specified account.
- `address payable(address)`: Returns the address of the specified account as a payable address.

Rust provides a number of functions for working with addresses. These functions include:

- `Env::get_current_contract_address(self)`: Returns the Address object corresponding to the current executing contract.
- Used as `e.current_contract_address()`
- `Env::get_current_contract_id(self)`: Returns the 32-byte hash identifier of the current executing contract.
- Used as `e.current_contract_id()`

The `Env` not only provides essential information about the currently executing contract and its invoker, but also offers access to contract data and functions for signing, hashing, and more. The construction or conversion of most types in Soroban requires access to an `Env` instance.

### Function Visibility Specifiers

Solidity provides a number of function visibility specifiers that can be used to control who can call a function. These specifiers include:

- `public`: Anyone can call the function.
- `external`: Only other contracts can call the function.
- `internal`: Only the current contract and contracts that inherit from it can call the function.
- `private`: Only the current contract can call the function.

Rust provides a number of function visibility specifiers that can be used to control who can call a function. These specifiers include:

- `pub`: Anyone can call the function.
- `pub(crate)`: Only other contracts can call the function.
- `pub(super)`: Only the current contract and contracts that inherit from it can call the function.
- `pub(self)`: Only the current contract can call the function.

### Time-Based Variables

Solidity provides a number of time-based variables that can be used to access information about the current block. These variables include:

- `block.timestamp`: The timestamp of the current block.
- `block.number`: The number of the current block.

Rust provides a number of time-based variables that can be used to access information about the current block. These variables include:

- `Env::get_ledger_timestamp(self.env())`: Returns a unix timestamp for when the ledger was closed.
- Used as `env.ledger().timestamp()`
- `Env::get_ledger_sequence(self.env())`: Returns the sequence number of the ledger.
- Used as `env.ledger().sequence()`

Overall the Rust equivalents of Solidity concepts are very similar. The main difference is that Rust uses `env` instead of `msg` to access information about the current transaction.

For more information on Solidity concepts and their Rust equivalents, it is recommend that one refer to both the [Soroban Rust SDK documentation](https://docs.rs/soroban-sdk/latest/soroban_sdk/struct.Env.html) and the [Solidity documentation](https://docs.soliditylang.org/en/v0.8.19/cheatsheet.html).
